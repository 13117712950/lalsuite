//
// Copyright (C) 2016 Karl Wette
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with with program; see the file COPYING. If not, write to the
// Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
// MA 02111-1307 USA
//

///
/// \file
/// \ingroup lalapps_pulsar_Weave
///

#include "Weave.h"
#include "SetupData.h"
#include "ComputeResults.h"
#include "CacheResults.h"
#include "OutputResults.h"

#include <lal/LogPrintf.h>
#include <lal/UserInput.h>
#include <lal/ExtrapolatePulsarSpins.h>

int main( int argc, char *argv[] )
{

  // Check VCS information
  XLAL_CHECK_MAIN( XLALAppsVCSInfoCheck() == XLAL_SUCCESS, XLAL_EFUNC );

  // Set help information
  lalUserVarHelpBrief = "search for gravitational-wave pulsars";

  ////////// Parse user input //////////

  // Optional arguments to XLALCreateFstatInput(), used to initialise some user input variables
  FstatOptionalArgs Fstat_opt_args = FstatOptionalArgsDefaults;

  // Initialise user input variables
  struct uvar_type {
    BOOLEAN interpolation, output_per_detector, output_per_segment, output_info_per_seg;
    CHAR *setup_file, *lattice, *sft_files, *Fstat_method, *output_file, *ckpt_output_file;
    INT4 sky_patch_count, sky_patch_index, freq_partitions, output_max_size;
    INT4 sft_noise_rand_seed, Fstat_run_med_window, Fstat_Dterms, Fstat_SSB_precision;
    INT4 cache_max_size, cache_gc_limit;
    LALStringVector *sft_noise_psd, *sft_timestamps_files, *injections, *Fstat_assume_psd;
    REAL8 semi_max_mismatch, coh_max_mismatch, sft_timebase, ckpt_output_period, ckpt_output_pc_exit;
    REAL8Range alpha, delta, freq, f1dot, f2dot, f3dot, f4dot;
  } uvar_struct = {
    .Fstat_Dterms = Fstat_opt_args.Dterms,
    .Fstat_SSB_precision = Fstat_opt_args.SSBprec,
    .Fstat_method = XLALStringDuplicate( "ResampBest" ),
    .Fstat_run_med_window = Fstat_opt_args.runningMedianWindow,
    .alpha = {0, LAL_TWOPI},
    .delta = {-LAL_PI_2, LAL_PI_2},
    .freq_partitions = 1,
    .interpolation = 1,
    .lattice = XLALStringDuplicate( "An-star" ),
    .output_max_size = 1000,
    .sft_noise_rand_seed = Fstat_opt_args.randSeed,
  };
  struct uvar_type *const uvar = &uvar_struct;

  // Register user input variables:
  //
  // - Setup file input
  //
  XLALRegisterUvarMember(
    setup_file, STRING, 'S', REQUIRED,
    "Setup file generated by lalapps_WeaveSetup; the segment list, parameter-space metrics, and other required data. "
    );
  //
  // - SFT input/generation and signal generation
  //
  XLALRegisterUvarMember(
    sft_files, STRING, 'D', OPTIONAL,
    "Pattern matching the SFT files to be analysed. Possibilities are:\n"
    " - '<SFT file>;<SFT file>;...', where <SFT file> may contain wildcards\n - 'list:<file containing list of SFT files>'"
    );
  XLALRegisterUvarMember(
    sft_timebase, REAL8, 't', OPTIONAL,
    "Generate SFTs with this timebase instead of loading from files. "
    );
  XLALRegisterUvarMember(
    sft_timestamps_files, STRINGVector, 'T', DEVELOPER,
    "Files containing timestamps for the generated SFTs. "
    "Arguments correspond to the detectors in the setup file given by " UVAR_STR( setup_file ) ". "
    "Timebase of the generated SFTs is specified by " UVAR_STR( sft_timebase ) ". "
    "If not given, SFTs with contiguous timestamps are generated. "
    );
  XLALRegisterUvarMember(
    sft_noise_psd, STRINGVector, 'p', OPTIONAL,
    "Inject fake Gaussian noise with these power spectral densities into the generated SFTs. "
    "Arguments correspond to the detectors in the setup file given by " UVAR_STR( setup_file ) ". "
    );
  XLALRegisterUvarMember(
    sft_noise_rand_seed, INT4, 0, OPTIONAL,
    "Random seed used to generate fake Gaussian noise for generated SFTs. "
    );
  XLALRegisterUvarMember(
    injections, STRINGVector, 'J', OPTIONAL,
    "Inject simulated CW signals in the loaded/generated SFTs. Possibilities are:\n"
    "  '{refTime=...; h0=...; cosi=...; psi=...; phi0=...; Alpha=...; Delta=...; Freq=...; f1dot=...; ...}'\n"
    "  '<config-file>,...'"
    );
  //
  // - Search parameter space
  //
  XLALRegisterUvarMember(
    alpha, RAJRange, 'a', NODEFAULT,
    "Search parameter space in right ascension. "
    "If not specified, an all-sky search is performed; otherwise " UVAR_STR( delta ) " must also be specified. "
    "Range for a partial-sky search is limited to PI radians. "
    );
  XLALRegisterUvarMember(
    delta, DECJRange, 'd', NODEFAULT,
    "Search parameter space in declination. "
    "If not specified, an all-sky search is performed; otherwise " UVAR_STR( alpha ) " must also be specified. "
    );
  XLALRegisterUvarMember(
    sky_patch_count, INT4, 'K', DEVELOPER,
    "Divide the entire sky into this number of ~equal-template-count patches. "
    "Requires " UVAR_STR( sky_patch_index ) ", mutually exclusive with " UVAR_STR2AND( alpha, delta ) ". "
    );
  XLALRegisterUvarMember(
    sky_patch_index, INT4, 'k', DEVELOPER,
    "Search the sky patch given by this index, from zero to one less than " UVAR_STR( sky_patch_count ) ". "
    "Requires " UVAR_STR( sky_patch_count ) ", mutually exclusive with " UVAR_STR2AND( alpha, delta ) ". "
    );
  XLALRegisterUvarMember(
    freq, REAL8Range, 'f', REQUIRED,
    "Search parameter space in frequency, in Hertz. "
    );
  XLALRegisterUvarMember(
    freq_partitions, INT4, 0, DEVELOPER,
    "Internally divide the frequency parameter space into this number of ~equal-width partitions. "
    );
  XLALRegisterUvarMember(
    f1dot, REAL8Range, '1', OPTIONAL,
    "Search parameter space in first spindown, in Hertz/second. "
    );
  XLALRegisterUvarMember(
    f2dot, REAL8Range, '2', OPTIONAL,
    "Search parameter space in second spindown, in Hertz/second^2. "
    );
  XLALRegisterUvarMember(
    f3dot, REAL8Range, '3', DEVELOPER,
    "Search parameter space in third spindown, in Hertz/second^3. "
    );
  XLALRegisterUvarMember(
    f4dot, REAL8Range, '4', DEVELOPER,
    "Search parameter space in fourth spindown, in Hertz/second^4. "
    "(Unlikely ever to be useful - unless a nearby supernova just went off!) "
    );
  //
  // - Lattice tiling setup
  //
  XLALRegisterUvarMember(
    semi_max_mismatch, REAL8, 's', REQUIRED,
    "Maximum metric mismatch of the lattice tiling on which semicoherent quantities are computed, e.g. F-statistics averaged over segments. "
    );
  XLALRegisterUvarMember(
    coh_max_mismatch, REAL8, 'c', OPTIONAL,
    "Maximum metric mismatch of the per-segment lattice tilings on which coherent quantities are computed, e.g. coherent F-statistics. "
    "If the search setup contains only 1 segment, then this option must not be specified. "
    );
  XLALRegisterUvarMember(
    interpolation, BOOLEAN, 'i', OPTIONAL,
    "If TRUE, perform interpolation from the semicoherent lattice tiling to the per-segment coherent lattice tilings; "
    UVAR_STR( coh_max_mismatch ) " must also be specified in this case. "
    "If FALSE, turn off interpolation and use the same lattice tiling for both semicoherent and coherent computations; "
    UVAR_STR( coh_max_mismatch ) " must not be specified in this case. "
    );
  XLALRegisterUvarMember(
    lattice, STRING, 'l', DEVELOPER,
    "Type of lattice used to generate the lattice tilings. Options are:\n"
    " - 'An-star': An-star lattice. Gives the thinnest tiling in low dimensions, and is therefore the default.\n"
    " - 'cubic':   Hypercubic lattice. Probably only useful for testing purposes. "
    );
  //
  // - F-statistic computation options
  //
  XLALRegisterUvarMember(
    Fstat_method, STRING, 'F', DEVELOPER,
    "Method used to calculate coherent F-statistics. Available methods:\n  %s", XLALFstatMethodHelpString()
    );
  XLALRegisterUvarMember(
    Fstat_run_med_window, INT4, 0, DEVELOPER,
    "Size of the running median window used to normalise SFTs and compute noise weight. "
    );
  XLALRegisterUvarMember(
    Fstat_assume_psd, STRINGVector, 0, DEVELOPER,
    "Normalise SFTs using the specified assumed noise spectral densities, instead of computing them from the SFTs themselves. "
    );
  XLALRegisterUvarMember(
    Fstat_Dterms, INT4, 0, DEVELOPER,
    "Number of Dirichlet kernel terms to use in computing the F-statistic. May not be available for all F-statistic methods. "
    );
  XLALRegisterUvarMember(
    Fstat_SSB_precision, INT4, 0, DEVELOPER,
    "Precision in calculating the barycentric transformation. Options are:\n"
    " - %i: Newtonian\n"
    " - %i: relativistic\n"
    " - %i: optimised relativistic",
    SSBPREC_NEWTONIAN,	SSBPREC_RELATIVISTIC,  SSBPREC_RELATIVISTICOPT
    );
  //
  // - Cache management options
  //
  XLALRegisterUvarMember(
    cache_max_size, INT4, 0, DEVELOPER,
    "Limit the size of the internal caches, used to store intermediate results, to this number of items per segment. "
    "If zero, the caches will grow in size to store all items that are still required. "
    "Has no effect when performing a fully-coherent single-segment search, or a non-interpolating search. "
    );
  XLALRegisterUvarMember(
    cache_gc_limit, INT4, 0, DEVELOPER,
    "By default, whenever an item is added to the internal caches, at most one item that is no longer required is removed. "
    "If non-zero, try to remove at most this number of additional items, providing they are no longer required. "
    "Has no effect when performing a fully-coherent single-segment search, or a non-interpolating search. "
    );
  //
  // - Output
  //
  XLALRegisterUvarMember(
    output_file, STRING, 'o', REQUIRED,
    "Output file which stores all quantities computed by the search, e.g. top-lists of averaged F-statistics. "
    );
  XLALRegisterUvarMember(
    output_max_size, INT4, 'N', OPTIONAL,
    "Maximum number of candidates to return in an output top-list; if 0, all candidates are returned. "
    );
  XLALRegisterUvarMember(
    output_per_detector, BOOLEAN, 'X', DEVELOPER,
    "If TRUE, compute and output per-detector quantities, e.g. single-detector F-statistics. "
    "May be combined with " UVAR_STR( output_per_segment ) ". "
    );
  XLALRegisterUvarMember(
    output_per_segment, BOOLEAN, 'G', DEVELOPER,
    "If TRUE, compute and output per-segment quantities, e.g. coherent F-statistics in each segment. "
    "May be combined with " UVAR_STR( output_per_detector ) ". "
    );
  XLALRegisterUvarMember(
    output_info_per_seg, BOOLEAN, 0, DEVELOPER,
    "If TRUE, output miscellaneous per-segment information: SFT properties, cache usage, etc. "
    );
  //
  // - Checkpointing
  //
  XLALRegisterUvarMember(
    ckpt_output_file, STRING, 0, DEVELOPER,
    "File to which to periodically write checkpoints of output results. "
    );
  XLALRegisterUvarMember(
    ckpt_output_period, REAL8, 0, DEVELOPER,
    "Write checkpoints of output results after this CPU time period, in seconds, has elapsed. "
    );
  XLALRegisterUvarMember(
    ckpt_output_pc_exit, REAL8, 0, DEVELOPER,
    "Write a checkpoint of output results after this percentage of the search has been completed, then exit. "
    "(This option is only really useful for testing the checkpointing feature.) "
    );

  // Parse user input
  XLAL_CHECK_MAIN( xlalErrno == 0, XLAL_EFUNC, "A call to XLALRegisterUvarMember() failed" );
  BOOLEAN should_exit = 0;
  XLAL_CHECK_MAIN( XLALUserVarReadAllInput( &should_exit, argc, argv ) == XLAL_SUCCESS, XLAL_EFUNC );

  // Check user input:
  //
  // - SFT input/generation and signal generation
  //
  XLALUserVarCheck( &should_exit,
                    UVAR_SET2( sft_files, sft_timebase ) == 1,
                    "Exactly one of " UVAR_STR2OR( sft_files, sft_timebase ) " must be specified" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( sft_files ) || !UVAR_ALLSET4( sft_timebase, sft_timestamps_files, sft_noise_psd, sft_noise_rand_seed ),
                    UVAR_STR( sft_files ) " are mutually exclusive with " UVAR_STR4AND( sft_timebase, sft_timestamps_files, sft_noise_psd, sft_noise_rand_seed ) );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( sft_timebase ) || uvar->sft_timebase > 0,
                    UVAR_STR( sft_timebase ) " must be strictly positive" );
  //
  // - Search parameter space
  //
  XLALUserVarCheck( &should_exit,
                    -LAL_PI_2 <= uvar->delta[0] && uvar->delta[1] <= LAL_PI_2,
                    UVAR_STR( delta ) " must be within range [-PI/2,PI/2]" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET2( sky_patch_count, sky_patch_index ) || !UVAR_ALLSET2( alpha, delta ),
                    UVAR_STR2AND( sky_patch_count, sky_patch_index ) " are mutually exclusive with " UVAR_STR2AND( alpha, delta ) );
  XLALUserVarCheck( &should_exit,
                    UVAR_SET2( sky_patch_count, sky_patch_index ) != 1,
                    UVAR_STR( sky_patch_count ) " requires " UVAR_STR( sky_patch_index ) " and vice versa" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( sky_patch_index ) || ( 0 < uvar->sky_patch_index && uvar->sky_patch_index < uvar->sky_patch_count ),
                    UVAR_STR( sky_patch_index ) " must be positive and strictly less than " UVAR_STR( sky_patch_count ) );
  XLALUserVarCheck( &should_exit,
                    uvar->freq_partitions > 0,
                    UVAR_STR( freq_partitions ) " must be strictly positive" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( f2dot ) || UVAR_SET( f1dot ),
                    UVAR_STR( f1dot ) " must be specified if " UVAR_STR( f2dot ) " is specified" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( f3dot ) || UVAR_SET( f2dot ),
                    UVAR_STR( f2dot ) " must be specified if " UVAR_STR( f3dot ) " is specified" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( f4dot ) || UVAR_SET( f3dot ),
                    UVAR_STR( f3dot ) " must be specified if " UVAR_STR( f4dot ) " is specified" );
  //
  // - Lattice tiling setup
  //
  XLALUserVarCheck( &should_exit,
                    uvar->semi_max_mismatch > 0,
                    UVAR_STR( semi_max_mismatch ) " must be strictly positive" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( coh_max_mismatch ) || uvar->coh_max_mismatch > 0,
                    UVAR_STR( coh_max_mismatch ) " must be strictly positive" );
  //
  // - F-statistic computation options
  //
  XLALUserVarCheck( &should_exit,
                    uvar->Fstat_run_med_window >= 0,
                    UVAR_STR( Fstat_run_med_window ) " must be positive" );
  XLALUserVarCheck( &should_exit,
                    uvar->Fstat_Dterms >= 0,
                    UVAR_STR( Fstat_Dterms ) " must be positive" );
  XLALUserVarCheck( &should_exit,
                    0 <= uvar->Fstat_SSB_precision && uvar->Fstat_SSB_precision < SSBPREC_LAST,
                    UVAR_STR( Fstat_SSB_precision ) " must be in range [0,%u)", SSBPREC_LAST );
  //
  // - Cache management options
  //
  XLALUserVarCheck( &should_exit,
                    uvar->cache_max_size >= 0,
                    UVAR_STR( cache_max_size ) " must be positive" );
  XLALUserVarCheck( &should_exit,
                    uvar->cache_gc_limit >= 0,
                    UVAR_STR( cache_gc_limit ) " must be positive" );
  //
  // - Output
  //
  XLALUserVarCheck( &should_exit,
                    uvar->output_max_size >= 0,
                    UVAR_STR( output_max_size ) " must be positive" );
  //
  // - Checkpointing
  //
  XLALUserVarCheck( &should_exit,
                    !UVAR_ALLSET2( ckpt_output_period, ckpt_output_pc_exit ),
                    UVAR_STR2AND( ckpt_output_period, ckpt_output_pc_exit ) " are mutually exclusive" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( ckpt_output_period ) || uvar->ckpt_output_period > 0,
                    UVAR_STR( ckpt_output_period ) " must be strictly positive" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( ckpt_output_pc_exit ) || ( 0 <= uvar->ckpt_output_pc_exit && uvar->ckpt_output_pc_exit <= 100 ),
                    UVAR_STR( ckpt_output_pc_exit ) " must be in range [0,100]" );

  // Exit if required
  if ( should_exit ) {
    return EXIT_FAILURE;
  }
  LogPrintf( LOG_NORMAL, "Parsed user input successfully\n" );

  ////////// Load setup data //////////

  // Initialise setup data
  WeaveSetupData XLAL_INIT_DECL( setup );

  {
    // Open setup file
    LogPrintf( LOG_NORMAL, "Opening setup file '%s' for reading ...\n", uvar->setup_file );
    FITSFile *file = XLALFITSFileOpenRead( uvar->setup_file );
    XLAL_CHECK_MAIN( file != NULL, XLAL_EFUNC );

    // Read setup data
    XLAL_CHECK_MAIN( XLALWeaveSetupDataRead( file, &setup ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Close output file
    XLALFITSFileClose( file );
    LogPrintf( LOG_NORMAL, "Closed setup file '%s'\n", uvar->setup_file );
  }

  // Print reference time
  LogPrintf( LOG_NORMAL, "Setup file reference time = %" LAL_GPS_FORMAT "\n", LAL_GPS_PRINT( setup.ref_time ) );

  // Concatenate list of detector into a string
  char *setup_detectors_string = XLALConcatStringVector( setup.detectors, "," );
  XLAL_CHECK_MAIN( setup_detectors_string != NULL, XLAL_EFUNC );

  // Compute segment list range
  const UINT4 nsegments = setup.segments->length;
  LIGOTimeGPS segments_start, segments_end;
  XLAL_CHECK_MAIN( XLALSegListRange( setup.segments, &segments_start, &segments_end ) == XLAL_SUCCESS, XLAL_EFUNC );
  LogPrintf( LOG_NORMAL, "Setup file segment list range = [%" LAL_GPS_FORMAT ", %" LAL_GPS_FORMAT "] GPS, segment count = %u\n", LAL_GPS_PRINT( segments_start ), LAL_GPS_PRINT( segments_end ), nsegments );

  // Create array of miscellaneous per-segment information
  WeaveOutputMiscPerSegInfo XLAL_INIT_ARRAY_DECL( per_seg_info, nsegments );
  for ( size_t i = 0; i < nsegments; ++i ) {
    per_seg_info[i].segment_start = setup.segments->segs[i].start;
    per_seg_info[i].segment_end = setup.segments->segs[i].end;
  }

  ////////// Set up lattice tilings //////////

  // If outputting per-detector quantities, list of detectors
  const LALStringVector *per_detectors = uvar->output_per_detector ? setup.detectors : NULL;

  // Number of per-segment items to output (may be zero)
  const UINT4 per_nsegments = uvar->output_per_segment ? nsegments : 0;

  // Check interpolation/maximum mismatch options are consistent with the type of search being performed
  if ( nsegments == 1 ) {
    XLALUserVarCheck( &should_exit,
                      !UVAR_SET( coh_max_mismatch ),
                      UVAR_STR( coh_max_mismatch ) " must not be specified if setup file '%s' contains only 1 segment", uvar->setup_file );
    XLALUserVarCheck( &should_exit,
                      !UVAR_SET( interpolation ) || !uvar->interpolation,
                      UVAR_STR( interpolation ) " must either be FALSE or not specified if setup file '%s' contains only 1 segment", uvar->setup_file );
  } else if ( uvar->interpolation ) {
    XLALUserVarCheck( &should_exit,
                      UVAR_SET( coh_max_mismatch ),
                      UVAR_STR( coh_max_mismatch ) " must be specified if " UVAR_STR( interpolation ) " is true" );
  } else {
    XLALUserVarCheck( &should_exit,
                      !UVAR_SET( coh_max_mismatch ),
                      UVAR_STR( coh_max_mismatch ) " must not be set if " UVAR_STR( interpolation ) " is false" );
  }
  if ( should_exit ) {
    return EXIT_FAILURE;
  }

  // Decide which mismatches to use, depending of whether this is an interpolating or non-interpolating search
  const BOOLEAN interpolation = ( nsegments > 1 ) ? uvar->interpolation : 0;
  const double semi_max_mismatch = uvar->semi_max_mismatch;
  const double coh_max_mismatch = interpolation ? uvar->coh_max_mismatch : semi_max_mismatch;
  if ( nsegments == 1 ) {
    LogPrintf( LOG_NORMAL, "Performing a fully-coherent single-segment search with maximum (semicoherent) mismatch = %.15g\n", semi_max_mismatch );
  } else if ( !interpolation ) {
    LogPrintf( LOG_NORMAL, "Performing a non-interpolating search with maximum (semicoherent) mismatch = %.15g\n", semi_max_mismatch );
  } else {
    LogPrintf( LOG_NORMAL, "Performing an interpolating search with maximum semicoherent mismatch = %.15g, maximum coherent mismatch = %.15g\n", semi_max_mismatch, coh_max_mismatch );
  }

  // Scale metrics to fiducial frequency, given by maximum search frequency
  XLAL_CHECK_MAIN( XLALScaleSuperskyMetricsFiducialFreq( setup.metrics, uvar->freq[1] ) == XLAL_SUCCESS, XLAL_EFUNC );
  LogPrintf( LOG_NORMAL, "Metric fiducial frequency set to maximum search frequency = %.15g Hz\n", uvar->freq[1] );

  // Equalise metric frequency spacing, given the specified maximum mismatches
  XLAL_CHECK_MAIN( XLALEqualizeReducedSuperskyMetricsFreqSpacing( setup.metrics, coh_max_mismatch, semi_max_mismatch ) == XLAL_SUCCESS, XLAL_EFUNC );

  // Copy input frequency/spindown ranges into an array for convenience
  REAL8Range fkdot[] = {
    { uvar->freq [0], uvar->freq [1] },
    { uvar->f1dot[0], uvar->f1dot[1] },
    { uvar->f2dot[0], uvar->f2dot[1] },
    { uvar->f3dot[0], uvar->f3dot[1] },
    { uvar->f4dot[0], uvar->f4dot[1] },
  };

  // Check that metrics computed in setup file have sufficient spindown dimensions to cover user input
  const size_t nmaxspins = XLAL_NUM_ELEM( fkdot ) - 1;
  size_t nmetricspins = 0;
  XLAL_CHECK_MAIN( XLALSuperskyMetricsDimensions( setup.metrics, &nmetricspins ) == XLAL_SUCCESS, XLAL_EFUNC );
  XLAL_CHECK_MAIN( nmetricspins <= nmaxspins, XLAL_EINVAL, "Number of spindowns from metrics (%zu) computed in setup file '%s' must be <= %zu", nmetricspins, uvar->setup_file, nmaxspins );
  const size_t ninputspins = UVAR_SET4( f1dot, f2dot, f3dot, f4dot );
  XLAL_CHECK_MAIN( ninputspins <= nmetricspins, XLAL_EINVAL, "Number of spindowns from user input (%zu) must be <= number of spindowns from metrics (%zu) computed in setup file '%s'", ninputspins, nmetricspins, uvar->setup_file );

  // Number of parameter-space dimensions: 2 for sky + 1 for frequency + 'nmetricspins' for spindowns
  const size_t ndim = 2 + 1 + nmetricspins;

  // Number of coherent parameter-space tilings
  // - If performing a fully-coherent search (i.e. of a single segment), we only need the semicoherent
  //   tiling; otherwise we need coherent tilings for each segment, plus the semicoherent tiling
  const size_t ncohtiles = ( nsegments > 1 ) ? nsegments : 0;

  // Total number of parameter-space tilings; always number of coherent tilings plus the semicoherent tiling
  const size_t ntiles = ncohtiles + 1;

  // Index of semicoherent tiling in arrays; always the last element
  const size_t isemi = ntiles - 1;

  // Create parameter-space tilings
  LatticeTiling *tiling[ntiles];
  for ( size_t i = 0; i < ntiles; ++i ) {
    tiling[i] = XLALCreateLatticeTiling( ndim );
    XLAL_CHECK_MAIN( tiling[i] != NULL, XLAL_EFUNC );
  }

  // Create arrays to store the appropriate parameter-space metrics for each tiling
  gsl_matrix *rssky_metric[nsegments];
  gsl_matrix *rssky_transf[nsegments];
  for ( size_t i = 0; i < nsegments; ++i ) {
    rssky_metric[i] = setup.metrics->coh_rssky_metric[i];
    rssky_transf[i] = setup.metrics->coh_rssky_transf[i];
  }
  rssky_metric[isemi] = setup.metrics->semi_rssky_metric;
  rssky_transf[isemi] = setup.metrics->semi_rssky_transf;

  // Set sky parameter-space bounds
  {
    double alpha1 = 0, alpha2 = 0, delta1 = 0, delta2 = 0;
    if ( UVAR_SET( sky_patch_count ) ) {
      XLAL_CHECK_MAIN( XLALComputePhysicalSkyEqualAreaPatch( &alpha1, &alpha2, &delta1, &delta2, uvar->sky_patch_count, uvar->sky_patch_index ) == XLAL_SUCCESS, XLAL_EFUNC );
      LogPrintf( LOG_NORMAL, "Search sky parameter space: sky patch %u of %u\n", uvar->sky_patch_index, uvar->sky_patch_count );
    } else {
      alpha1 = uvar->alpha[0];
      alpha2 = uvar->alpha[1];
      delta1 = uvar->delta[0];
      delta2 = uvar->delta[1];
    }
    for ( size_t i = 0; i < ncohtiles; ++i ) {
      XLAL_CHECK_MAIN( XLALSetSuperskyPhysicalSkyBounds( tiling[i], rssky_metric[i], rssky_transf[i], alpha1, alpha2, delta1, delta2 ) == XLAL_SUCCESS, XLAL_EFUNC );
    }
    XLAL_CHECK_MAIN( XLALSetSuperskyPhysicalSkyBounds( tiling[isemi], rssky_metric[isemi], rssky_transf[isemi], alpha1, alpha2, delta1, delta2 ) == XLAL_SUCCESS, XLAL_EFUNC );
    LogPrintf( LOG_NORMAL, "Search sky parameter space: right ascension [%.15g, %.15g] rad, declination [%.15g, %.15g] rad\n", alpha1, alpha2, delta1, delta2 );
  }

  // Set frequency/spindown parameter-space bounds
  for ( size_t s = 0; s <= nmetricspins; ++s ) {
    for ( size_t i = 0; i < ncohtiles; ++i ) {
      XLAL_CHECK_MAIN( XLALSetSuperskyPhysicalSpinBound( tiling[i], rssky_transf[i], s, fkdot[s][0], fkdot[s][1] ) == XLAL_SUCCESS, XLAL_EFUNC );
    }
    XLAL_CHECK_MAIN( XLALSetSuperskyPhysicalSpinBound( tiling[isemi], rssky_transf[isemi], s, fkdot[s][0], fkdot[s][1] ) == XLAL_SUCCESS, XLAL_EFUNC );
    if ( s == 0 ) {
      LogPrintf( LOG_NORMAL, "Search frequency parameter space: [%.15g, %.15g] Hz\n", fkdot[s][0], fkdot[s][1] );
    } else {
      LogPrintf( LOG_NORMAL, "Search %zu-order spindown parameter space: [%.15g, %.15g] Hz/s^%zu\n", s, fkdot[s][0], fkdot[s][1], s );
    }
  }

  // Set parameter-space lattice and metric
  for ( size_t i = 0; i < ncohtiles; ++i ) {
    XLAL_CHECK_MAIN( XLALSetTilingLatticeAndMetric( tiling[i], uvar->lattice, rssky_metric[i], coh_max_mismatch ) == XLAL_SUCCESS, XLAL_EFUNC );
  }
  XLAL_CHECK_MAIN( XLALSetTilingLatticeAndMetric( tiling[isemi], uvar->lattice, rssky_metric[isemi], semi_max_mismatch ) == XLAL_SUCCESS, XLAL_EFUNC );

  // Print number of (tiled) parameter-space dimensions
  LogPrintf( LOG_NORMAL, "Number of (tiled) parameter-space dimensions = %zu (%zu)\n", ndim, XLALTiledLatticeTilingDimensions( tiling[isemi] ) );

  // Get frequency spacing used by parameter-space tiling
  // - XLALEqualizeReducedSuperskyMetricsFreqSpacing() ensures this is the same for all segments
  const double dfreq = XLALLatticeTilingStepSizes( tiling[isemi], ndim - 1 );

  ////////// Load input data //////////

  // Load or generate SFT catalog
  SFTCatalog *sft_catalog = NULL;
  if ( UVAR_SET( sft_files ) ) {

    // Load SFT catalog from files given by 'sft_files'
    sft_catalog = XLALSFTdataFind( uvar->sft_files, NULL );
    XLAL_CHECK_MAIN( sft_catalog != NULL, XLAL_EFUNC );
    LogPrintf( LOG_NORMAL, "Loaded SFT catalog from SFTs matching '%s'\n", uvar->sft_files );

  } else {

    // Create timestamps for generated SFTs
    MultiLIGOTimeGPSVector *sft_timestamps = NULL;
    if ( UVAR_SET( sft_timestamps_files ) ) {

      // Check that the number of SFT timestamp files is consistent with the number of detectors
      XLAL_CHECK_MAIN( uvar->sft_timestamps_files->length == setup.detectors->length, XLAL_EINVAL, "Number SFT timestamp files (%i) is inconsistent with number of detectors (%i) in setup file '%s'", uvar->sft_timestamps_files->length, setup.detectors->length, uvar->setup_file );

      // Load SFT timestamps from files given by 'sft_timestamps_files'
      sft_timestamps = XLALReadMultiTimestampsFiles( uvar->sft_timestamps_files );
      XLAL_CHECK_MAIN( sft_timestamps != NULL, XLAL_EFUNC );
      for ( size_t i = 0; i < setup.detectors->length; ++i ) {
        sft_timestamps->data[i]->deltaT = uvar->sft_timebase;
        LogPrintf( LOG_NORMAL, "Loaded SFT timestamps for detector '%s' from file '%s'\n", setup.detectors->data[i], uvar->sft_timestamps_files->data[i] );
      }

    } else {

      // Generate identical SFT timestamps for each detector, starting from beginning of segment list, with timebase given by 'sft_timebase'
      sft_timestamps = XLALMakeMultiTimestamps( segments_start, XLALGPSDiff( &segments_end, &segments_start ), uvar->sft_timebase, 0, setup.detectors->length );
      XLAL_CHECK_MAIN( sft_timestamps != NULL, XLAL_EFUNC );
      LogPrintf( LOG_NORMAL, "Generated SFT timestamps for %i detectors, timebase = %.15g sec\n", setup.detectors->length, uvar->sft_timebase );

    }

    // Generate SFT catalog for detectors 'sft_detectors' and timestamps 'sft_timestamps'
    sft_catalog = XLALMultiAddToFakeSFTCatalog( sft_catalog, setup.detectors, sft_timestamps );
    XLAL_CHECK_MAIN( sft_catalog != NULL, XLAL_EFUNC );

    // Cleanup
    XLALDestroyMultiTimestamps( sft_timestamps );

  }

  // Check that all SFT catalog detectors were included in metrics computed in setup file
  {
    LALStringVector *sft_catalog_detectors = XLALListIFOsInCatalog( sft_catalog );
    XLAL_CHECK_MAIN( sft_catalog_detectors != NULL, XLAL_EFUNC );
    char *sft_catalog_detectors_string = XLALConcatStringVector( sft_catalog_detectors, "," );
    XLAL_CHECK_MAIN( sft_catalog_detectors_string != NULL, XLAL_EFUNC );
    XLAL_CHECK_MAIN( strcmp( sft_catalog_detectors_string, setup_detectors_string ) == 0, XLAL_EINVAL, "List of detectors '%s' in SFT catalog differs from list of detectors '%s' in setup file '%s'", sft_catalog_detectors_string, setup_detectors_string, uvar->setup_file );
    XLALDestroyStringVector( sft_catalog_detectors );
    XLALFree( sft_catalog_detectors_string );
  }

  // Record SFT timebase
  const double sft_timebase = 1.0 / sft_catalog->data[0].header.deltaF;

  // Parse signal injection string
  PulsarParamsVector *injections = NULL;
  if ( UVAR_SET( injections ) ) {
    injections = XLALPulsarParamsFromUserInput( uvar->injections );
    XLAL_CHECK_MAIN( injections != NULL, XLAL_EFUNC );
  }

  // Parse F-statistic method string
  FstatMethodType Fstat_method;
  XLAL_CHECK_MAIN( XLALParseFstatMethodString( &Fstat_method, uvar->Fstat_method ) == XLAL_SUCCESS, XLAL_EINVAL, "Invalid value '%s' for F-statistic method", uvar->Fstat_method );

  // Set F-statistic optional arguments
  Fstat_opt_args.randSeed = uvar->sft_noise_rand_seed;
  Fstat_opt_args.SSBprec = uvar->Fstat_SSB_precision;
  Fstat_opt_args.Dterms = uvar->Fstat_Dterms;
  Fstat_opt_args.runningMedianWindow = uvar->Fstat_run_med_window;
  Fstat_opt_args.FstatMethod = Fstat_method;
  Fstat_opt_args.injectSources = injections;
  Fstat_opt_args.prevInput = NULL;

  // Create input data required for computing coherent results
  WeaveCohInput *coh_input[nsegments];
  for ( size_t i = 0; i < nsegments; ++i ) {
    const LIGOTimeGPS *segment_start = &setup.segments->segs[i].start;
    const LIGOTimeGPS *segment_end = &setup.segments->segs[i].end;

    // Get a timeslice of SFT catalog restricted to range of 'i'th segment
    SFTCatalog sft_catalog_i;
    XLAL_CHECK_MAIN( XLALSFTCatalogTimeslice( &sft_catalog_i, sft_catalog, segment_start, segment_end ) == XLAL_SUCCESS, XLAL_EFUNC );
    XLAL_CHECK_MAIN( sft_catalog_i.length > 0, XLAL_EINVAL, "No SFTs found for segment %zu", i );
    MultiSFTCatalogView *sft_catalog_i_view = XLALGetMultiSFTCatalogView( &sft_catalog_i );
    XLAL_CHECK_MAIN( sft_catalog_i_view != NULL, XLAL_EINVAL );
    for ( size_t j = 0; j < sft_catalog_i_view->length; ++j ) {
      XLAL_CHECK_MAIN( sft_catalog_i_view->data[j].length > 0, XLAL_EINVAL, "No SFTs found for segment %zu, detector %zu", i, j );
    }

    // Get list of detectors of SFT catalog in 'i'th segment
    LALStringVector *sft_catalog_i_detectors = XLALListIFOsInCatalog( &sft_catalog_i );
    XLAL_CHECK_MAIN( sft_catalog_i_detectors != NULL, XLAL_EFUNC );

    // Get spindown range covered by parameter-space tiling of 'i'th segment
    PulsarSpinRange XLAL_INIT_DECL( spin_range );
    XLAL_CHECK_MAIN( XLALSuperskyLatticePulsarSpinRange( &spin_range, tiling[i], rssky_transf[i] ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Compute frequency range covered by spindown range over 'i'th segment
    LIGOTimeGPS sft_start = sft_catalog_i.data[0].header.epoch;
    LIGOTimeGPS sft_end = sft_catalog_i.data[sft_catalog_i.length - 1].header.epoch;
    XLALGPSAdd( &sft_end, sft_timebase );
    double min_cover_freq = 0, max_cover_freq = 0;
    XLAL_CHECK_MAIN( XLALCWSignalCoveringBand( &min_cover_freq, &max_cover_freq, &sft_start, &sft_end, &spin_range, 0, 0, 0 ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Parse SFT noise PSD string vector
    MultiNoiseFloor sft_noise_psd;
    if ( UVAR_SET( sft_noise_psd ) ) {
      XLAL_CHECK_MAIN( XLALParseMultiNoiseFloorMapped( &sft_noise_psd, sft_catalog_i_detectors, uvar->sft_noise_psd, setup.detectors ) == XLAL_SUCCESS, XLAL_EFUNC );
      Fstat_opt_args.injectSqrtSX = &sft_noise_psd;
    }

    // Parse F-statistic assumed PSD string vector
    MultiNoiseFloor Fstat_assume_psd;
    if ( UVAR_SET( Fstat_assume_psd ) ) {
      XLAL_CHECK_MAIN( XLALParseMultiNoiseFloorMapped( &Fstat_assume_psd, sft_catalog_i_detectors, uvar->Fstat_assume_psd, setup.detectors ) == XLAL_SUCCESS, XLAL_EFUNC );
      Fstat_opt_args.injectSqrtSX = &Fstat_assume_psd;
    }

    // Create F-statistic input data
    FstatInput *Fstat_input = XLALCreateFstatInput( &sft_catalog_i, min_cover_freq, max_cover_freq, dfreq, setup.ephemerides, &Fstat_opt_args );
    XLAL_CHECK_MAIN( Fstat_input != NULL, XLAL_EFUNC );
    Fstat_opt_args.prevInput = Fstat_input;

    // Create coherent input data for 'i'th segment
    coh_input[i] = XLALWeaveCohInputCreate( Fstat_input, per_detectors );
    XLAL_CHECK_MAIN( coh_input[i] != NULL, XLAL_EFUNC );

    // Record SFT information
    for ( size_t j = 0; j < sft_catalog_i_view->length; ++j ) {
      char *det_name = XLALGetChannelPrefix( sft_catalog_i_view->data[j].data[0].header.name );
      const int k = XLALFindStringInVector( det_name, setup.detectors );
      if ( k >= 0 ) {
        const UINT4 length = sft_catalog_i_view->data[j].length;
        per_seg_info[i].sft_first[k] = sft_catalog_i_view->data[j].data[0].header.epoch;
        per_seg_info[i].sft_last[k] = sft_catalog_i_view->data[j].data[length - 1].header.epoch;
        per_seg_info[i].sft_count[k] = length;
      }
      XLALFree( det_name );
    }
    per_seg_info[i].min_cover_freq = min_cover_freq;
    per_seg_info[i].max_cover_freq = max_cover_freq;

    // Cleanup
    XLALDestroyMultiSFTCatalogView( sft_catalog_i_view );
    XLALDestroyStringVector( sft_catalog_i_detectors );

  }

  // Cleanup SFT catalog
  XLALDestroySFTCatalog( sft_catalog );

  // Create caches to store intermediate results from coherent parameter-space tilings
  // - If no interpolation, caching is not required so reduce maximum cache size to 1
  WeaveCache *coh_cache[nsegments];
  for ( size_t i = 0; i < nsegments; ++i ) {
    const size_t cache_max_size = interpolation ? uvar->cache_max_size : 1;
    const size_t cache_gc_limit = interpolation ? uvar->cache_gc_limit : 0;
    coh_cache[i] = XLALWeaveCacheCreate( tiling[i], interpolation, setup.phys_to_latt, setup.latt_to_phys, rssky_transf[i], rssky_transf[isemi], coh_input[i], cache_max_size, cache_gc_limit, uvar->output_info_per_seg );
    XLAL_CHECK_MAIN( coh_cache[i] != NULL, XLAL_EFUNC );
  }

  ////////// Perform search //////////

  // Create iterator over semicoherent tiling
  // - The last parameter-space dimension is always frequency and is not iterated over, since we
  //   always operate over a block of frequencies at once. Since the frequency spacing is always
  //   equal over all tilings due to XLALEqualizeReducedSuperskyMetricsFreqSpacing(), operations
  //   such as nearest point finding can be performed once per frequency block instead of per bin.
  LatticeTilingIterator *semi_itr = XLALCreateLatticeTilingIterator( tiling[isemi], ndim - 1 );
  XLAL_CHECK_MAIN( semi_itr != NULL, XLAL_EFUNC );
  gsl_vector *GAVEC_MAIN( semi_rssky, ndim );

  // Create storage for cache queries for coherent results in each segment
  WeaveCacheQueries *queries = XLALWeaveCacheQueriesCreate( tiling[isemi], setup.phys_to_latt, setup.latt_to_phys, rssky_transf[isemi], nsegments, uvar->freq_partitions );
  XLAL_CHECK_MAIN( queries != NULL, XLAL_EFUNC );

  // Create storage for semicoherent results
  WeaveSemiResults *semi_res = XLALWeaveSemiResultsCreate( per_detectors, per_nsegments, dfreq );
  XLAL_CHECK_MAIN( semi_res != NULL, XLAL_EFUNC );

  // Create output results structure
  WeaveOutputResults *out = XLALWeaveOutputResultsCreate( &setup.ref_time, ninputspins, per_detectors, per_nsegments, uvar->output_max_size );
  XLAL_CHECK_MAIN( out != NULL, XLAL_EFUNC );

  // Count number of semicoherent frequency blocks
  LogPrintf( LOG_NORMAL, "Counting number of semicoherent frequency blocks ...\n" );
  const UINT8 semi_total = XLALTotalLatticeTilingPoints( semi_itr );
  LogPrintf( LOG_NORMAL, "Number of semicoherent frequency blocks = %" LAL_UINT8_FORMAT "\n", semi_total );
  const UINT8 prog_total = uvar->freq_partitions * semi_total;

  // Semicoherent template and partition indexes
  UINT8 semi_index = 0;
  INT4 partition_index = 0;

  // Number of times output results have been restored from a checkpoint
  INT4 ckpt_output_count = 0;

  // Try to restore output results from a checkpoint file, if given
  if ( UVAR_SET( ckpt_output_file ) ) {

    // Try to open output checkpoint file
    LogPrintf( LOG_NORMAL, "Trying to open output checkpoint file '%s' for reading ...\n", uvar->ckpt_output_file );
    int errnum = 0;
    FITSFile *file = NULL;
    XLAL_TRY( file = XLALFITSFileOpenRead( uvar->ckpt_output_file ), errnum );
    if ( errnum == XLAL_ENOENT ) {
      LogPrintf( LOG_NORMAL, "Output checkpoint file '%s' does not exist; no checkpoint will be loaded\n", uvar->ckpt_output_file );
    } else {
      XLAL_CHECK_MAIN( errnum == 0 && file != NULL, XLAL_EFUNC );
      LogPrintf( LOG_NORMAL, "Output checkpoint file '%s' exists; checkpoint will be loaded\n", uvar->ckpt_output_file );

      // Read number of times output results have been restored from a checkpoint
      XLAL_CHECK_MAIN( XLALFITSHeaderReadINT4( file, "ckptcnt", &ckpt_output_count ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( ckpt_output_count > 0, XLAL_EIO, "Invalid output checkpoint file '%s'", uvar->ckpt_output_file );

      // Read output results
      XLAL_CHECK_MAIN( XLALWeaveOutputResultsReadAppend( file, &out ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Read state of iterator over semicoherent tiling
      XLAL_CHECK_MAIN( XLALRestoreLatticeTilingIterator( semi_itr, file, "semi_itr" ) == XLAL_SUCCESS, XLAL_EFUNC );
      semi_index = XLALCurrentLatticeTilingIndex( semi_itr );
      XLAL_CHECK_MAIN( semi_index < semi_total, XLAL_EIO, "Invalid output checkpoint file '%s'", uvar->ckpt_output_file );

      // Read partition index
      XLAL_CHECK_MAIN( XLALFITSHeaderReadINT4( file, "partindx", &partition_index ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( 0 <= partition_index && partition_index < uvar->freq_partitions, XLAL_EIO, "Invalid output checkpoint file '%s'", uvar->ckpt_output_file );

      // Close output checkpoint file
      XLALFITSFileClose( file );
      LogPrintf( LOG_NORMAL, "Closed output checkpoint file '%s'\n", uvar->ckpt_output_file );

    }

  }

  // Record zero of CPU time counter
  const double time_zero = XLALGetCPUTime();

  // Print initial progress in frequency blocks and partitions
  {
    const UINT8 prog_index = partition_index * semi_total + semi_index;
    const double prog_per_cent = 100.0 * prog_index / prog_total;
    LogPrintf( LOG_NORMAL, "Starting main search loop at %" LAL_UINT8_FORMAT "/%" LAL_UINT8_FORMAT " frequency blocks (%.1f%%)", prog_index, prog_total, prog_per_cent );
    if ( uvar->freq_partitions > 1 ) {
      LogPrintfVerbatim( LOG_NORMAL, ", partition %i/%i", partition_index, uvar->freq_partitions );
    }
    LogPrintfVerbatim( LOG_NORMAL, ", peak memory = %.1fMB ...\n", XLALGetPeakHeapUsageMB() );
  }

  // Begin main search loop
  double prog_time = time_zero;
  double prog_period = 5.0;
  double ckpt_output_time = time_zero;
  BOOLEAN search_complete = 0;
  while ( !search_complete ) {

    // Get mid-point of the next semicoherent frequency block
    // - XLALNextLatticeTilingPoint() returns mid-point in non-iterated dimensions
    const int itr_retn = XLALNextLatticeTilingPoint( semi_itr, semi_rssky );
    XLAL_CHECK_MAIN( itr_retn >= 0, XLAL_EFUNC );
    if ( itr_retn == 0 ) {

      // Move to the next partition
      ++partition_index;
      semi_index = 0;
      if ( partition_index == uvar->freq_partitions ) {

        // Search is complete
        search_complete = 1;
        continue;

      }

      // Reset iterator over semicoherent tiling
      XLAL_CHECK_MAIN( XLALResetLatticeTilingIterator( semi_itr ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALNextLatticeTilingPoint( semi_itr, semi_rssky ) > 0, XLAL_EFUNC );

    }

    // Initialise cache queries
    XLAL_CHECK_MAIN( XLALWeaveCacheQueriesInit( queries, semi_itr, semi_rssky ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Query for coherent results for each segment
    for ( size_t i = 0; i < nsegments; ++i ) {
      XLAL_CHECK_MAIN( XLALWeaveCacheQuery( coh_cache[i], semi_index, queries, i ) == XLAL_SUCCESS, XLAL_EFUNC );
    }

    // Finalise cache queries
    PulsarDopplerParams XLAL_INIT_DECL( semi_phys );
    UINT4 semi_nfreqs = 0;
    XLAL_CHECK_MAIN( XLALWeaveCacheQueriesFinal( queries, partition_index, &semi_phys, dfreq, &semi_nfreqs ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Initialise semicoherent results
    XLAL_CHECK_MAIN( XLALWeaveSemiResultsInit( semi_res, &semi_phys, semi_nfreqs ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Add coherent results from each segment
    for ( size_t i = 0; i < nsegments; ++i ) {

      // Retrieve coherent results for this segment
      const WeaveCohResults *coh_res = NULL;
      UINT4 coh_offset = 0;
      XLAL_CHECK_MAIN( XLALWeaveCacheRetrieve( coh_cache[i], queries, i, &coh_res, &coh_offset, &per_seg_info[i] ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( coh_res != NULL, XLAL_EFUNC );

      // Add coherent results to semicoherent results
      XLAL_CHECK_MAIN( XLALWeaveSemiResultsAdd( semi_res, coh_res, coh_offset ) == XLAL_SUCCESS, XLAL_EFUNC );

    }

    // Add semicoherent results to output
    XLAL_CHECK_MAIN( XLALWeaveOutputResultsAdd( out, semi_res, semi_nfreqs ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Increment semicoherent template index
    ++semi_index;

    // Print iteration progress, if required
    const UINT8 prog_index = partition_index * semi_total + semi_index;
    const double prog_per_cent = 100.0 * prog_index / prog_total;
    const double prog_time_now = XLALGetCPUTime();
    const double prog_time_elapsed = prog_time_now - prog_time;
    if ( prog_time_elapsed >= prog_period ) {
      prog_time = prog_time_now;

      // Print progress in frequency blocks and partitions
      LogPrintf( LOG_NORMAL, "Searched %" LAL_UINT8_FORMAT "/%" LAL_UINT8_FORMAT " frequency blocks (%.1f%%)", prog_index, prog_total, prog_per_cent );
      if ( uvar->freq_partitions > 1 ) {
        LogPrintfVerbatim( LOG_NORMAL, ", partition %i/%i", partition_index, uvar->freq_partitions );
      }

      // Print progress in time
      const double prog_time_remain = prog_time_elapsed * ( prog_total - prog_index ) / prog_index;
      LogPrintfVerbatim( LOG_NORMAL, ", CPU time elapsed %.1f sec, remaining ~%.1f sec", prog_time_elapsed, prog_time_remain );

      // Print memory usage
      LogPrintfVerbatim( LOG_NORMAL, ", peak memory = %.1fMB", XLALGetPeakHeapUsageMB() );

      // Finish progress printing
      LogPrintfVerbatim( LOG_NORMAL, "\n" );

      // Increase progress period, up to a maximum
      prog_period = GSL_MIN( 1200, prog_period * 1.5 );

    }

    // Checkpoint output results, if required
    if ( UVAR_SET( ckpt_output_file ) ) {

      // Decide whether to checkpoint output results
      const double ckpt_output_time_now = XLALGetCPUTime();
      const double ckpt_output_time_elapsed = ckpt_output_time_now - ckpt_output_time;
      const BOOLEAN do_ckpt_output_period = UVAR_SET( ckpt_output_period ) && ckpt_output_time_elapsed >= uvar->ckpt_output_period;
      const BOOLEAN do_ckpt_output_pc_exit = UVAR_SET( ckpt_output_pc_exit ) && prog_per_cent >= uvar->ckpt_output_pc_exit;
      if ( do_ckpt_output_period || do_ckpt_output_pc_exit ) {

        // Open output checkpoint file
        FITSFile *file = XLALFITSFileOpenWrite( uvar->ckpt_output_file );
        XLAL_CHECK_MAIN( file != NULL, XLAL_EFUNC );
        XLAL_CHECK_MAIN( XLALFITSFileWriteVCSInfo( file, lalAppsVCSInfoList ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK_MAIN( XLALFITSFileWriteUVarCmdLine( file ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Write number of times output results have been restored from a checkpoint
        ++ckpt_output_count;
        XLAL_CHECK_MAIN( XLALFITSHeaderWriteINT4( file, "ckptcnt", ckpt_output_count, "number of checkpoints" ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Write output results
        XLAL_CHECK_MAIN( XLALWeaveOutputResultsWrite( file, out ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Write state of iterator over semicoherent tiling
        XLAL_CHECK_MAIN( XLALSaveLatticeTilingIterator( semi_itr, file, "semi_itr" ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Write partition index
        XLAL_CHECK_MAIN( XLALFITSHeaderWriteINT4( file, "partindx", partition_index, "partition index" ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Close output checkpoint file
        XLALFITSFileClose( file );

        // Print progress
        LogPrintf( LOG_NORMAL, "Wrote output checkpoint to file '%s' after %.1f time elapsed, %" LAL_UINT8_FORMAT " frequency blocks\n", uvar->ckpt_output_file, ckpt_output_time_elapsed, semi_index );

      }

      // Update checkpoint time, if checkpointing was triggered by 'do_ckpt_output_period'
      if ( do_ckpt_output_period ) {
        ckpt_output_time = ckpt_output_time_now;
      }

      // Exit main search loop, if checkpointing was triggered by 'do_ckpt_output_pc_exit'
      if ( do_ckpt_output_pc_exit ) {
        LogPrintf( LOG_NORMAL, "Exiting main seach loop after writing output checkpoint\n" );
        break;
      }

    }

  }

  // Record elapsed CPU time
  const double time_elapsed = XLALGetCPUTime() - time_zero;

  // Print final progress in frequency blocks and partitions
  {
    const UINT8 prog_index = partition_index * semi_total + semi_index;
    const double prog_per_cent = 100.0 * prog_index / prog_total;
    LogPrintf( LOG_NORMAL, "Finished main search loop at %" LAL_UINT8_FORMAT "/%" LAL_UINT8_FORMAT " frequency blocks (%.1f%%)", prog_index, prog_total, prog_per_cent );
    if ( uvar->freq_partitions > 1 ) {
      LogPrintfVerbatim( LOG_NORMAL, ", partition %i/%i", partition_index, uvar->freq_partitions );
    }
    LogPrintfVerbatim( LOG_NORMAL, ", CPU time elapsed %.1f sec, peak memory = %.1fMB\n", time_elapsed, XLALGetPeakHeapUsageMB() );
  }

  ////////// Output search results //////////

  if ( search_complete ) {

    // Open output file
    LogPrintf( LOG_NORMAL, "Opening output file '%s' for writing ...\n", uvar->output_file );
    FITSFile *file = XLALFITSFileOpenWrite( uvar->output_file );
    XLAL_CHECK_MAIN( file != NULL, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSFileWriteVCSInfo( file, lalAppsVCSInfoList ) == XLAL_SUCCESS, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSFileWriteUVarCmdLine( file ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Write search results
    XLAL_CHECK_MAIN( XLALWeaveOutputResultsWrite( file, out ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Write miscellaneous per-segment information
    if ( uvar->output_info_per_seg ) {

      // Begin FITS table
      XLAL_CHECK( XLALFITSTableOpenWrite( file, "per_seg_info", "miscellaneous information per segment" ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Describe FITS table
      {
        char col_name[32];
        XLAL_FITS_TABLE_COLUMN_BEGIN( WeaveOutputMiscPerSegInfo );
        XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, GPSTime, segment_start ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, GPSTime, segment_end ) == XLAL_SUCCESS, XLAL_EFUNC );
        for ( size_t i = 0; i < setup.detectors->length; ++i ) {
          snprintf( col_name, sizeof( col_name ), "sft_first_%s", setup.detectors->data[i] );
          XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD_NAMED( file, GPSTime, sft_first[i], col_name ) == XLAL_SUCCESS, XLAL_EFUNC );
          snprintf( col_name, sizeof( col_name ), "sft_last_%s", setup.detectors->data[i] );
          XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD_NAMED( file, GPSTime, sft_last[i], col_name ) == XLAL_SUCCESS, XLAL_EFUNC );
          snprintf( col_name, sizeof( col_name ), "sft_count_%s", setup.detectors->data[i] );
          XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD_NAMED( file, INT4, sft_count[i], col_name ) == XLAL_SUCCESS, XLAL_EFUNC );
        }
        XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, REAL8, min_cover_freq ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, REAL8, max_cover_freq ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, INT4, coh_total ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, INT4, coh_total_recomp ) == XLAL_SUCCESS, XLAL_EFUNC );
      }

      // Write FITS table
      for ( size_t i = 0; i < nsegments; ++i ) {
        XLAL_CHECK( XLALFITSTableWriteRow( file, &per_seg_info[i] ) == XLAL_SUCCESS, XLAL_EFUNC );
      }

    }

    // Close output file
    XLALFITSFileClose( file );
    LogPrintf( LOG_NORMAL, "Closed output file '%s'\n", uvar->output_file );
  }

  ////////// Cleanup memory and exit //////////

  // Cleanup memory from output results
  XLALWeaveOutputResultsDestroy( out );

  // Cleanup memory from parameter-space iteration
  XLALDestroyLatticeTilingIterator( semi_itr );
  XLALWeaveSemiResultsDestroy( semi_res );

  // Cleanup memory from computing coherent results
  XLALWeaveCacheQueriesDestroy( queries );
  for ( size_t i = 0; i < nsegments; ++i ) {
    XLALWeaveCacheDestroy( coh_cache[i] );
  }
  for ( size_t i = 0; i < nsegments; ++i ) {
    XLALWeaveCohInputDestroy( coh_input[i] );
  }

  // Cleanup memory from lattice tilings
  for ( size_t i = 0; i < ntiles; ++i ) {
    XLALDestroyLatticeTiling( tiling[i] );
  }

  // Cleanup memory from setup data
  XLALWeaveSetupDataClear( &setup );
  XLALFree( setup_detectors_string );

  // Cleanup memory from user input
  XLALDestroyUserVars();
  XLALDestroyPulsarParamsVector( injections );

  // Check for memory leaks
  LALCheckMemoryLeaks();

  if ( search_complete ) {
    LogPrintf( LOG_NORMAL, "Finished successfully!\n" );
  } else {
    LogPrintf( LOG_NORMAL, "Finished but search not completed!\n" );
  }

  return EXIT_SUCCESS;

}

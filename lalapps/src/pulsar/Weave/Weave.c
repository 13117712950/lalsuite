//
// Copyright (C) 2016, 2017 Karl Wette
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with with program; see the file COPYING. If not, write to the
// Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
// MA 02111-1307 USA
//

///
/// \file
/// \ingroup lalapps_pulsar_Weave
///

#include "Weave.h"
#include "SetupData.h"
#include "ComputeResults.h"
#include "CacheResults.h"
#include "OutputResults.h"

#include <lal/LogPrintf.h>
#include <lal/UserInput.h>
#include <lal/Random.h>
#include <lal/ExtrapolatePulsarSpins.h>

#ifdef WEAVE_CALLGRIND   // Set when compiling lalapps_Weave_Callgrind
#include <valgrind/callgrind.h>
#endif

///
/// Internal definition of miscellaneous per-segment information
///
typedef struct {
  /// Start time of segment
  LIGOTimeGPS segment_start;
  /// End time of segment
  LIGOTimeGPS segment_end;
  /// Timestamp of first SFT from each detector
  LIGOTimeGPS sft_first[PULSAR_MAX_DETECTORS];
  /// Timestamp of last SFT from each detector
  LIGOTimeGPS sft_last[PULSAR_MAX_DETECTORS];
  /// Number of SFTs from each detector
  UINT4 sft_count[PULSAR_MAX_DETECTORS];
  /// Minimum of frequency range covered by SFTs
  REAL8 sft_min_cover_freq;
  /// Maximum of frequency range covered by SFTs
  REAL8 sft_max_cover_freq;
  /// Number of coherent results computed once
  UINT4 coh_n1comp;
  /// Number of recomputed coherent results
  UINT4 coh_nrecomp;
} misc_per_seg_info;

// Return elapsed wall time in seconds
static inline double wall_time(void) { return XLALGetTimeOfDay(); }

// Return elapsed CPU time in seconds
static inline double cpu_time(void) { return XLALGetCPUTime(); }

int main( int argc, char *argv[] )
{

#ifdef WEAVE_CALLGRIND   // Set when compiling lalapps_Weave_Callgrind
  // Do not profile setup
  CALLGRIND_STOP_INSTRUMENTATION;
#endif

  // Set help information
  lalUserVarHelpBrief = "search for gravitational-wave pulsars";

  ////////// Parse user input //////////

  // Optional arguments to XLALCreateFstatInput(), used to initialise some user input variables
  FstatOptionalArgs Fstat_opt_args = FstatOptionalArgsDefaults;

  // Initialise user input variables
  struct uvar_type {
    BOOLEAN validate_sft_files, interpolation, lattice_rand_offset, per_detector, per_segment, misc_info, simulate_search;
    CHAR *setup_file, *sft_files, *output_file, *ckpt_output_file;
    LALStringVector *sft_timestamps_files, *sft_noise_psd, *injections, *Fstat_assume_psd;
    REAL8 sft_timebase, semi_max_mismatch, coh_max_mismatch, ckpt_output_period, ckpt_output_exit;
    REAL8Range alpha, delta, freq, f1dot, f2dot, f3dot, f4dot;
    UINT4 sky_patch_count, sky_patch_index, freq_partitions, Fstat_run_med_window, Fstat_Dterms, toplist_limit, rand_seed, cache_max_size, cache_gc_limit;
    int lattice, Fstat_method, Fstat_SSB_precision, toplists;
  } uvar_struct = {
    .Fstat_Dterms = Fstat_opt_args.Dterms,
    .Fstat_SSB_precision = Fstat_opt_args.SSBprec,
    .Fstat_method = FMETHOD_RESAMP_BEST,
    .Fstat_run_med_window = Fstat_opt_args.runningMedianWindow,
    .alpha = {0, LAL_TWOPI},
    .delta = {-LAL_PI_2, LAL_PI_2},
    .freq_partitions = 1,
    .interpolation = 1,
    .lattice = TILING_LATTICE_ANSTAR,
    .toplist_limit = 1000,
    .toplists = WEAVE_TOPLIST_RANKED_MEAN2F,
  };
  struct uvar_type *const uvar = &uvar_struct;

  // Register user input variables:
  //
  // - General
  //
  XLALRegisterUvarMember(
    setup_file, STRING, 'S', REQUIRED,
    "Setup file generated by lalapps_WeaveSetup; the segment list, parameter-space metrics, and other required data. "
    );
  XLALRegisterUvarMember(
    output_file, STRING, 'o', REQUIRED,
    "Output file which stores all quantities computed by lalapps_Weave. "
    );
  //
  // - SFT input/generation and signal generation
  //
  lalUserVarHelpOptionSubsection = "SFT input/generation and signal generation";
  XLALRegisterUvarMember(
    sft_files, STRING, 'I', NODEFAULT,
    "Pattern matching the SFT files to be analysed. Possibilities are:\n"
    " - '<SFT file>;<SFT file>;...', where <SFT file> may contain wildcards\n - 'list:<file containing list of SFT files>'"
    );
  XLALRegisterUvarMember(
    validate_sft_files, BOOLEAN, 'V', DEVELOPER,
    "Perform the following checks to validate the SFTs matched by " UVAR_STR( sft_files ) ":\n"
    " - Validate the checksums of the SFTs before loading them into memory.\n"
    " - Check that the number of SFTs in each segment matches the number provided by the segment list in the setup file given by " UVAR_STR( setup_file ) ".\n"
    );
  XLALRegisterUvarMember(
    sft_timebase, REAL8, 't', NODEFAULT,
    "Generate SFTs with this timebase instead of loading from files. "
    );
  XLALRegisterUvarMember(
    sft_timestamps_files, STRINGVector, 'T', DEVELOPER,
    "Files containing timestamps for the generated SFTs; if not given, SFTs with contiguous timestamps are generated. "
    "Arguments correspond to the detectors in the setup file given by " UVAR_STR( setup_file )
    "; for example, if the setup file was created with " UVAR_STR( detectors ) " set to 'H1,L1', then an argument of "
    "'t1.txt,t2.txt' to this option will read H1 timestamps from the file 't1.txt', and L1 timestamps from the file 't2.txt'. "
    "The timebase of the generated SFTs is specified by " UVAR_STR( sft_timebase ) ". "
    );
  XLALRegisterUvarMember(
    sft_noise_psd, STRINGVector, 'p', NODEFAULT,
    "Inject fake Gaussian noise with these power spectral densities (PSDs) into the generated SFTs. "
    "Arguments correspond to the detectors in the setup file given by " UVAR_STR( setup_file )
    "; for example, if the setup file was created with " UVAR_STR( detectors ) " set to 'H1,L1', then an argument of "
    "'1.2,3.4' to this option will generate H1 SFTs with a noise PSD of 1.2, and L1 SFTs with a noise PSD of 3.4. "
    );
  XLALRegisterUvarMember(
    injections, STRINGVector, 'J', NODEFAULT,
    "Inject simulated CW signals in the loaded/generated SFTs. Possibilities for <string> are:\n"
    "  <config-file>\n"
    "  {parameter=value; ...} where:\n"
    "    required parameters are: (h0, cosi) or (aPlus, aCross), Alpha, Delta, Freq\n"
    "    optional parameters are: refTime, psi, phi0, f<n>dot, ..."
    );
  //
  // - Search parameter space
  //
  lalUserVarHelpOptionSubsection = "Search parameter space";
  XLALRegisterUvarMember(
    alpha, RAJRange, 'a', NODEFAULT,
    "Search parameter space in right ascension. "
    "If not specified, an all-sky search is performed; otherwise " UVAR_STR( delta ) " must also be specified. "
    "Range for a partial-sky search is limited to PI radians. "
    );
  XLALRegisterUvarMember(
    delta, DECJRange, 'd', NODEFAULT,
    "Search parameter space in declination. "
    "If not specified, an all-sky search is performed; otherwise " UVAR_STR( alpha ) " must also be specified. "
    );
  XLALRegisterUvarMember(
    sky_patch_count, UINT4, 'K', DEVELOPER,
    "Divide the entire sky into this number of ~equal-template-count patches. "
    "Requires " UVAR_STR( sky_patch_index ) ", mutually exclusive with " UVAR_STR2AND( alpha, delta ) ". "
    );
  XLALRegisterUvarMember(
    sky_patch_index, UINT4, 'k', DEVELOPER,
    "Search the sky patch given by this index, from zero to one less than " UVAR_STR( sky_patch_count ) ". "
    "Requires " UVAR_STR( sky_patch_count ) ", mutually exclusive with " UVAR_STR2AND( alpha, delta ) ". "
    );
  XLALRegisterUvarMember(
    freq, REAL8Range, 'f', REQUIRED,
    "Search parameter space in frequency, in Hertz. "
    );
  XLALRegisterUvarMember(
    freq_partitions, UINT4, 'r', DEVELOPER,
    "Internally divide the frequency parameter space into this number of ~equal-width partitions. "
    );
  XLALRegisterUvarMember(
    f1dot, REAL8Range, '1', OPTIONAL,
    "Search parameter space in first spindown, in Hertz/second. "
    );
  XLALRegisterUvarMember(
    f2dot, REAL8Range, '2', OPTIONAL,
    "Search parameter space in second spindown, in Hertz/second^2. "
    );
  XLALRegisterUvarMember(
    f3dot, REAL8Range, '3', DEVELOPER,
    "Search parameter space in third spindown, in Hertz/second^3. "
    );
  XLALRegisterUvarMember(
    f4dot, REAL8Range, '4', DEVELOPER,
    "Search parameter space in fourth spindown, in Hertz/second^4. "
    "(Just in case a nearby supernova goes off!) "
    );
  //
  // - Lattice tiling setup
  //
  lalUserVarHelpOptionSubsection = "Lattice tiling setup";
  XLALRegisterUvarMember(
    semi_max_mismatch, REAL8, 's', REQUIRED,
    "Maximum metric mismatch of the lattice tiling on which semicoherent quantities are computed, e.g. F-statistics averaged over segments. "
    );
  XLALRegisterUvarMember(
    coh_max_mismatch, REAL8, 'c', NODEFAULT,
    "Maximum metric mismatch of the per-segment lattice tilings on which coherent quantities are computed, e.g. coherent F-statistics. "
    "If the search setup contains only 1 segment, then this option must not be specified. "
    );
  XLALRegisterUvarMember(
    interpolation, BOOLEAN, 'i', OPTIONAL,
    "If TRUE, perform interpolation from the semicoherent lattice tiling to the per-segment coherent lattice tilings; "
    UVAR_STR( coh_max_mismatch ) " must also be specified in this case. "
    "If FALSE, turn off interpolation and use the same lattice tiling for both semicoherent and coherent computations; "
    UVAR_STR( coh_max_mismatch ) " must not be specified in this case. "
    );
  XLALRegisterUvarAuxDataMember(
    lattice, UserEnum, &TilingLatticeChoices, 'l', DEVELOPER,
    "Type of lattice used to generate the lattice tilings. "
    );
  XLALRegisterUvarMember(
    lattice_rand_offset, BOOLEAN, 'j', DEVELOPER,
    "If given, offset the physical parameter-space origin of the lattice tilings by a random fraction of the lattice step size. "
    "This is important when performing mismatch studies to ensure that the mismatch distribution is fully sampled. "
    );
  //
  // - F-statistic computation
  //
  lalUserVarHelpOptionSubsection = "F-statistic computation";
  XLALRegisterUvarAuxDataMember(
    Fstat_method, UserEnum, XLALFstatMethodChoices(), 'm', DEVELOPER,
    "Method used to calculate the F-statistic. "
    );
  XLALRegisterUvarMember(
    Fstat_run_med_window, UINT4, 'w', DEVELOPER,
    "Size of the running median window used to normalise SFTs and compute noise weight. "
    );
  XLALRegisterUvarMember(
    Fstat_assume_psd, STRINGVector, 'q', DEVELOPER,
    "Assume that the noise in the SFTs have known power spectral densities (PSDs), which are given by the arguments to "
    "this option, and normalise the SFTs by these given PSDs. "
    "Arguments correspond to the detectors in the setup file given by " UVAR_STR( setup_file )
    "; for example, if the setup file was created with " UVAR_STR( detectors ) " set to 'H1,L1', then an argument of "
    "'3.2,4.3' to this option will assume that H1 SFTs contain noise with a PSD of 3.2, and L1 SFTs contain noise with a PSD of 4.3. "
    "If this option is not given, the SFTs are normalised using noise PSDs estimated from the SFTs themselves. "
    );
  XLALRegisterUvarMember(
    Fstat_Dterms, UINT4, 0, DEVELOPER,
    "Number of Dirichlet kernel terms to use in computing the F-statistic. May not be available for all F-statistic methods. "
    );
  XLALRegisterUvarAuxDataMember(
    Fstat_SSB_precision, UserEnum, &SSBprecisionChoices, 0, DEVELOPER,
    "Precision in calculating the barycentric transformation. "
    );
  //
  // - Output control
  //
  lalUserVarHelpOptionSubsection = "Output control";
  XLALRegisterUvarAuxDataMember(
    toplists, UserFlag, &WeaveToplistTypeChoices, 'L', OPTIONAL,
    "Sets which combination of toplists to return in the output file given by " UVAR_STR( output_file ) "."
    );
  XLALRegisterUvarMember(
    toplist_limit, UINT4, 'n', OPTIONAL,
    "Maximum number of candidates to return in an output toplist; if 0, all candidates are returned. "
    );
  XLALRegisterUvarMember(
    per_detector, BOOLEAN, 'D', DEVELOPER,
    "If TRUE, compute and output per-detector quantities, e.g. single-detector F-statistics. "
    "May be combined with " UVAR_STR( per_segment ) ". "
    );
  XLALRegisterUvarMember(
    per_segment, BOOLEAN, 'N', DEVELOPER,
    "If TRUE, compute and output per-segment quantities, e.g. coherent F-statistics in each segment. "
    "May be combined with " UVAR_STR( per_detector ) ". "
    );
  XLALRegisterUvarMember(
    misc_info, BOOLEAN, 'M', DEVELOPER,
    "If TRUE, output miscellaneous per-segment information: SFT properties, cache usage, etc. "
    );
  //
  // - Checkpointing
  //
  lalUserVarHelpOptionSubsection = "Checkpointing";
  XLALRegisterUvarMember(
    ckpt_output_file, STRING, 'C', DEVELOPER,
    "File to which to periodically write checkpoints of output results. "
    );
  XLALRegisterUvarMember(
    ckpt_output_period, REAL8, 'z', DEVELOPER,
    "Write checkpoints of output results after this CPU time period, in seconds, has elapsed. "
    );
  XLALRegisterUvarMember(
    ckpt_output_exit, REAL8, 0, DEVELOPER,
    "Write a checkpoint of output results after this fraction of the search has been completed, then exit. "
    "Arguments to this option must be in the range [0,1]. "
    "(This option is only really useful for testing the checkpointing feature.) "
    );
  //
  // - Esoterica
  //
  lalUserVarHelpOptionSubsection = "Esoterica";
  XLALRegisterUvarMember(
    rand_seed, UINT4, 'e', DEVELOPER,
    "Random seed used to initialise random number generators. "
    );
   XLALRegisterUvarMember(
     simulate_search, BOOLEAN, 0, DEVELOPER,
     "Simulate search; perform all search actions apart from computing any results. "
     "If SFT parameters (i.e. " UVAR_STR( sft_files ) " or " UVAR_STR( sft_timebase ) ") are supplied, simulate search with full memory allocation, i.e. with F-statistic input data, cached coherent results, etc. "
     "Otherwise, perform search with minimal memory allocation, i.e. do not allocate memory for any data or results. "
     );
  XLALRegisterUvarMember(
    cache_max_size, UINT4, 0, DEVELOPER,
    "Limit the size of the internal caches, used to store intermediate results, to this number of items per segment. "
    "If zero, the caches will grow in size to store all items that are still required. "
    "Has no effect when performing a fully-coherent single-segment search, or a non-interpolating search. "
    );
  XLALRegisterUvarMember(
    cache_gc_limit, UINT4, 0, DEVELOPER,
    "By default, whenever an item is added to the internal caches, at most one item that is no longer required is removed. "
    "If non-zero, try to remove at most this number of additional items, providing they are no longer required. "
    "Has no effect when performing a fully-coherent single-segment search, or a non-interpolating search. "
    );

  // Parse user input
  XLAL_CHECK_MAIN( xlalErrno == 0, XLAL_EFUNC, "A call to XLALRegisterUvarMember() failed" );
  BOOLEAN should_exit = 0;
  XLAL_CHECK_MAIN( XLALUserVarReadAllInput( &should_exit, argc, argv, lalAppsVCSInfoList ) == XLAL_SUCCESS, XLAL_EFUNC );

  // Check user input:
  //
  // - General
  //

  //
  // - SFT input/generation and signal generation
  //
  XLALUserVarCheck( &should_exit,
                    uvar->simulate_search || UVAR_SET2( sft_files, sft_timebase ) == 1,
                    "Exactly one of " UVAR_STR2OR( sft_files, sft_timebase ) " must be specified" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( sft_files ) || !UVAR_ALLSET3( sft_timebase, sft_timestamps_files, sft_noise_psd ),
                    UVAR_STR( sft_files ) " are mutually exclusive with " UVAR_STR3AND( sft_timebase, sft_timestamps_files, sft_noise_psd ) );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( validate_sft_files ) || UVAR_SET( sft_files ),
                    UVAR_STR( validate_sft_files ) " requires " UVAR_STR( sft_files ) );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( sft_timebase ) || uvar->sft_timebase > 0,
                    UVAR_STR( sft_timebase ) " must be strictly positive" );
  //
  // - Search parameter space
  //
  XLALUserVarCheck( &should_exit,
                    -LAL_PI_2 <= uvar->delta[0] && uvar->delta[1] <= LAL_PI_2,
                    UVAR_STR( delta ) " must be within range [-PI/2,PI/2]" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET2( sky_patch_count, sky_patch_index ) || !UVAR_ALLSET2( alpha, delta ),
                    UVAR_STR2AND( sky_patch_count, sky_patch_index ) " are mutually exclusive with " UVAR_STR2AND( alpha, delta ) );
  XLALUserVarCheck( &should_exit,
                    UVAR_SET2( sky_patch_count, sky_patch_index ) != 1,
                    UVAR_STR( sky_patch_count ) " requires " UVAR_STR( sky_patch_index ) " and vice versa" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( sky_patch_index ) || uvar->sky_patch_index < uvar->sky_patch_count,
                    UVAR_STR( sky_patch_index ) " must be positive and strictly less than " UVAR_STR( sky_patch_count ) );
  XLALUserVarCheck( &should_exit,
                    uvar->freq_partitions > 0,
                    UVAR_STR( freq_partitions ) " must be strictly positive" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( f1dot ) || UVAR_SET( freq ),
                    UVAR_STR( freq ) " must be specified if " UVAR_STR( f1dot ) " is specified" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( f2dot ) || UVAR_SET( f1dot ),
                    UVAR_STR( f1dot ) " must be specified if " UVAR_STR( f2dot ) " is specified" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( f3dot ) || UVAR_SET( f2dot ),
                    UVAR_STR( f2dot ) " must be specified if " UVAR_STR( f3dot ) " is specified" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( f4dot ) || UVAR_SET( f3dot ),
                    UVAR_STR( f3dot ) " must be specified if " UVAR_STR( f4dot ) " is specified" );
  //
  // - Lattice tiling setup
  //
  XLALUserVarCheck( &should_exit,
                    uvar->semi_max_mismatch > 0,
                    UVAR_STR( semi_max_mismatch ) " must be strictly positive" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( coh_max_mismatch ) || uvar->coh_max_mismatch > 0,
                    UVAR_STR( coh_max_mismatch ) " must be strictly positive" );
  //
  // - F-statistic computation
  //
  XLALUserVarCheck( &should_exit,
                    uvar->Fstat_SSB_precision < SSBPREC_LAST,
                    UVAR_STR( Fstat_SSB_precision ) " must be in range [0,%u)", SSBPREC_LAST );
  //
  // - Output control
  //

  //
  // - Checkpointing
  //
  XLALUserVarCheck( &should_exit,
                    !UVAR_ALLSET2( ckpt_output_period, ckpt_output_exit ),
                    UVAR_STR2AND( ckpt_output_period, ckpt_output_exit ) " are mutually exclusive" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( ckpt_output_period ) || uvar->ckpt_output_period > 0,
                    UVAR_STR( ckpt_output_period ) " must be strictly positive" );
  XLALUserVarCheck( &should_exit,
                    !UVAR_SET( ckpt_output_exit ) || ( 0 <= uvar->ckpt_output_exit && uvar->ckpt_output_exit <= 1 ),
                    UVAR_STR( ckpt_output_exit ) " must be in range [0,1]" );
  //
  // - Esoterica
  //

  // Exit if required
  if ( should_exit ) {
    return EXIT_FAILURE;
  }
  LogPrintf( LOG_NORMAL, "Parsed user input successfully\n" );

  // Log whether search is being simulated
  if ( uvar->simulate_search ) {
    LogPrintf( LOG_NORMAL, "Simulating search; no results will be computed\n" );
  }

  ////////// Load setup data //////////

  // Initialise setup data
  WeaveSetupData XLAL_INIT_DECL( setup );

  {
    // Open setup file
    LogPrintf( LOG_NORMAL, "Opening setup file '%s' for reading ...\n", uvar->setup_file );
    FITSFile *file = XLALFITSFileOpenRead( uvar->setup_file );
    XLAL_CHECK_MAIN( file != NULL, XLAL_EFUNC );

    // Read setup data
    XLAL_CHECK_MAIN( XLALWeaveSetupDataRead( file, &setup ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Close output file
    XLALFITSFileClose( file );
    LogPrintf( LOG_NORMAL, "Closed setup file '%s'\n", uvar->setup_file );
  }

  // Print reference time
  LogPrintf( LOG_NORMAL, "Setup file reference time = %" LAL_GPS_FORMAT "\n", LAL_GPS_PRINT( setup.ref_time ) );

  // Number of detectors and segments
  const UINT4 ndetectors = setup.detectors->length;
  const UINT4 nsegments = setup.segments->length;

  // Concatenate list of detector into a string
  char *setup_detectors_string = XLALConcatStringVector( setup.detectors, "," );
  XLAL_CHECK_MAIN( setup_detectors_string != NULL, XLAL_EFUNC );

  // Compute segment list range
  LIGOTimeGPS segments_start, segments_end;
  XLAL_CHECK_MAIN( XLALSegListRange( setup.segments, &segments_start, &segments_end ) == XLAL_SUCCESS, XLAL_EFUNC );
  LogPrintf( LOG_NORMAL, "Setup file segment list range = [%" LAL_GPS_FORMAT ", %" LAL_GPS_FORMAT "] GPS, segment count = %u\n", LAL_GPS_PRINT( segments_start ), LAL_GPS_PRINT( segments_end ), nsegments );

  // Create array of miscellaneous per-segment information
  misc_per_seg_info XLAL_INIT_DECL( per_seg_info, [nsegments] );
  for ( size_t i = 0; i < nsegments; ++i ) {
    per_seg_info[i].segment_start = setup.segments->segs[i].start;
    per_seg_info[i].segment_end = setup.segments->segs[i].end;
  }

  ////////// Set up lattice tilings //////////

  // If outputting per-detector quantities, list of detectors
  const LALStringVector *per_detectors = uvar->per_detector ? setup.detectors : NULL;

  // Number of per-segment items to output (may be zero)
  const UINT4 per_nsegments = uvar->per_segment ? nsegments : 0;

  // Check interpolation/maximum mismatch options are consistent with the type of search being performed
  if ( nsegments == 1 ) {
    XLALUserVarCheck( &should_exit,
                      !UVAR_SET( coh_max_mismatch ),
                      UVAR_STR( coh_max_mismatch ) " must not be specified if setup file '%s' contains only 1 segment", uvar->setup_file );
    XLALUserVarCheck( &should_exit,
                      !UVAR_SET( interpolation ) || !uvar->interpolation,
                      UVAR_STR( interpolation ) " must either be FALSE or not specified if setup file '%s' contains only 1 segment", uvar->setup_file );
  } else if ( uvar->interpolation ) {
    XLALUserVarCheck( &should_exit,
                      UVAR_SET( coh_max_mismatch ),
                      UVAR_STR( coh_max_mismatch ) " must be specified if " UVAR_STR( interpolation ) " is true" );
  } else {
    XLALUserVarCheck( &should_exit,
                      !UVAR_SET( coh_max_mismatch ),
                      UVAR_STR( coh_max_mismatch ) " must not be set if " UVAR_STR( interpolation ) " is false" );
  }
  if ( should_exit ) {
    return EXIT_FAILURE;
  }

  // Decide which mismatches to use, depending of whether this is an interpolating or non-interpolating search
  const BOOLEAN interpolation = ( nsegments > 1 ) ? uvar->interpolation : 0;
  const double semi_max_mismatch = uvar->semi_max_mismatch;
  const double coh_max_mismatch = interpolation ? uvar->coh_max_mismatch : semi_max_mismatch;
  if ( nsegments == 1 ) {
    LogPrintf( LOG_NORMAL, "Performing a fully-coherent single-segment search with maximum (semicoherent) mismatch = %.15g\n", semi_max_mismatch );
  } else if ( !interpolation ) {
    LogPrintf( LOG_NORMAL, "Performing a non-interpolating search with maximum (semicoherent) mismatch = %.15g\n", semi_max_mismatch );
  } else {
    LogPrintf( LOG_NORMAL, "Performing an interpolating search with maximum semicoherent mismatch = %.15g, maximum coherent mismatch = %.15g\n", semi_max_mismatch, coh_max_mismatch );
  }

  // Scale metrics to fiducial frequency, given by maximum search frequency
  XLAL_CHECK_MAIN( XLALScaleSuperskyMetricsFiducialFreq( setup.metrics, uvar->freq[1] ) == XLAL_SUCCESS, XLAL_EFUNC );
  LogPrintf( LOG_NORMAL, "Metric fiducial frequency set to maximum search frequency = %.15g Hz\n", uvar->freq[1] );

  // Equalise metric frequency spacing, given the specified maximum mismatches
  XLAL_CHECK_MAIN( XLALEqualizeReducedSuperskyMetricsFreqSpacing( setup.metrics, coh_max_mismatch, semi_max_mismatch ) == XLAL_SUCCESS, XLAL_EFUNC );

  // Copy parameter-space ranges into an array for convenience
  // - If using sky patches, set the sky parameter-space ranges from the sky patch index/count
  enum { psialpha, psidelta, psifreq };
  REAL8Range ps[] = {
    [psialpha]  = { uvar->alpha[0], uvar->alpha[1] },
    [psidelta]  = { uvar->delta[0], uvar->delta[1] },
    [psifreq+0] = { uvar->freq [0], uvar->freq [1] },
    [psifreq+1] = { uvar->f1dot[0], uvar->f1dot[1] },
    [psifreq+2] = { uvar->f2dot[0], uvar->f2dot[1] },
    [psifreq+3] = { uvar->f3dot[0], uvar->f3dot[1] },
    [psifreq+4] = { uvar->f4dot[0], uvar->f4dot[1] },
  };
  const size_t nmaxspins = XLAL_NUM_ELEM( ps ) - psifreq + 1;
  if ( UVAR_SET( sky_patch_count ) ) {
    XLAL_CHECK_MAIN( XLALComputePhysicalSkyEqualAreaPatch( &ps[psialpha][0], &ps[psialpha][1], &ps[psidelta][0], &ps[psidelta][1], uvar->sky_patch_count, uvar->sky_patch_index ) == XLAL_SUCCESS, XLAL_EFUNC );
  }

  // Check that metrics computed in setup file have sufficient spindown dimensions to cover user input
  size_t nmetricspins = 0;
  XLAL_CHECK_MAIN( XLALSuperskyMetricsDimensions( setup.metrics, &nmetricspins ) == XLAL_SUCCESS, XLAL_EFUNC );
  XLAL_CHECK_MAIN( nmetricspins <= nmaxspins, XLAL_EINVAL, "Number of spindowns from metrics (%zu) computed in setup file '%s' must be <= %zu", nmetricspins, uvar->setup_file, nmaxspins );
  const size_t ninputspins = UVAR_SET4( f1dot, f2dot, f3dot, f4dot );
  XLAL_CHECK_MAIN( ninputspins <= nmetricspins, XLAL_EINVAL, "Number of spindowns from user input (%zu) must be <= number of spindowns from metrics (%zu) computed in setup file '%s'", ninputspins, nmetricspins, uvar->setup_file );

  // Number of parameter-space dimensions: 2 for sky + 1 for frequency + 'nmetricspins' for spindowns
  const size_t ndim = 2 + 1 + nmetricspins;

  // Number of coherent parameter-space tilings
  // - If performing a fully-coherent search (i.e. of a single segment), we only need the semicoherent
  //   tiling; otherwise we need coherent tilings for each segment, plus the semicoherent tiling
  const size_t ncohtiles = ( nsegments > 1 ) ? nsegments : 0;

  // Total number of parameter-space tilings; always number of coherent tilings plus the semicoherent tiling
  const size_t ntiles = ncohtiles + 1;

  // Index of semicoherent tiling in arrays; always the last element
  const size_t isemi = ntiles - 1;

  // Create parameter-space tilings
  LatticeTiling *XLAL_INIT_DECL( tiling, [ntiles] );
  for ( size_t i = 0; i < ntiles; ++i ) {
    tiling[i] = XLALCreateLatticeTiling( ndim );
    XLAL_CHECK_MAIN( tiling[i] != NULL, XLAL_EFUNC );
  }

  // Create arrays to store the appropriate parameter-space metrics for each tiling
  gsl_matrix *XLAL_INIT_DECL( rssky_metric, [ntiles] );
  SuperskyTransformData *XLAL_INIT_DECL( rssky_transf, [ntiles] );
  for ( size_t i = 0; i < nsegments; ++i ) {
    rssky_metric[i] = setup.metrics->coh_rssky_metric[i];
    rssky_transf[i] = setup.metrics->coh_rssky_transf[i];
  }
  rssky_metric[isemi] = setup.metrics->semi_rssky_metric;
  rssky_transf[isemi] = setup.metrics->semi_rssky_transf;

  // Set sky parameter-space bounds
  {
    for ( size_t i = 0; i < ncohtiles; ++i ) {
      XLAL_CHECK_MAIN( XLALSetSuperskyPhysicalSkyBounds( tiling[i], rssky_metric[i], rssky_transf[i], ps[psialpha][0], ps[psialpha][1], ps[psidelta][0], ps[psidelta][1] ) == XLAL_SUCCESS, XLAL_EFUNC );
    }
    XLAL_CHECK_MAIN( XLALSetSuperskyPhysicalSkyBounds( tiling[isemi], rssky_metric[isemi], rssky_transf[isemi], ps[psialpha][0], ps[psialpha][1], ps[psidelta][0], ps[psidelta][1] ) == XLAL_SUCCESS, XLAL_EFUNC );
    if ( UVAR_SET( sky_patch_count ) ) {
      LogPrintf( LOG_NORMAL, "Search sky parameter space = sky patch %u of %u\n", uvar->sky_patch_index, uvar->sky_patch_count );
    }
    LogPrintf( LOG_NORMAL, "Search sky parameter space = right ascension [%.15g, %.15g] rad, declination [%.15g, %.15g] rad\n", ps[psialpha][0], ps[psialpha][1], ps[psidelta][0], ps[psidelta][1] );
  }

  // Set frequency/spindown parameter-space bounds
  for ( size_t s = 0; s <= nmetricspins; ++s ) {
    for ( size_t i = 0; i < ncohtiles; ++i ) {
      XLAL_CHECK_MAIN( XLALSetSuperskyPhysicalSpinBound( tiling[i], rssky_transf[i], s, ps[psifreq+s][0], ps[psifreq+s][1] ) == XLAL_SUCCESS, XLAL_EFUNC );
    }
    XLAL_CHECK_MAIN( XLALSetSuperskyPhysicalSpinBound( tiling[isemi], rssky_transf[isemi], s, ps[psifreq+s][0], ps[psifreq+s][1] ) == XLAL_SUCCESS, XLAL_EFUNC );
    if ( s == 0 ) {
      LogPrintf( LOG_NORMAL, "Search frequency parameter space = [%.15g, %.15g] Hz\n", ps[psifreq+s][0], ps[psifreq+s][1] );
    } else {
      LogPrintf( LOG_NORMAL, "Search %zu-order spindown parameter space = [%.15g, %.15g] Hz/s^%zu\n", s, ps[psifreq+s][0], ps[psifreq+s][1], s );
    }
  }

  // Set parameter-space padding
  for ( size_t i = 0; i < ncohtiles; ++i ) {
    XLAL_CHECK_MAIN( XLALSetLatticeTilingPadding( tiling[i], interpolation ? 2 : 1 ) == XLAL_SUCCESS, XLAL_EFUNC );
  }
  XLAL_CHECK_MAIN( XLALSetLatticeTilingPadding( tiling[isemi], 1 ) == XLAL_SUCCESS, XLAL_EFUNC );

  // Add random offsets to physical origin of lattice tilings, if requested
  if ( UVAR_SET( lattice_rand_offset ) ) {
    RandomParams *rand_par = XLALCreateRandomParams( uvar->rand_seed );
    XLAL_CHECK_MAIN( rand_par != NULL, XLAL_EFUNC );
    for ( size_t i = 0; i < ntiles; ++i ) {
      XLAL_CHECK_MAIN( XLALSetLatticeTilingRandomOriginOffsets( tiling[i], rand_par ) == XLAL_SUCCESS, XLAL_EFUNC );
    }
    XLALDestroyRandomParams( rand_par );
  }

  // Set parameter-space lattice and metric
  for ( size_t i = 0; i < ncohtiles; ++i ) {
    XLAL_CHECK_MAIN( XLALSetTilingLatticeAndMetric( tiling[i], uvar->lattice, rssky_metric[i], coh_max_mismatch ) == XLAL_SUCCESS, XLAL_EFUNC );
  }
  XLAL_CHECK_MAIN( XLALSetTilingLatticeAndMetric( tiling[isemi], uvar->lattice, rssky_metric[isemi], semi_max_mismatch ) == XLAL_SUCCESS, XLAL_EFUNC );

  // Print number of (tiled) parameter-space dimensions
  LogPrintf( LOG_NORMAL, "Number of (tiled) parameter-space dimensions = %zu (%zu)\n", ndim, XLALTiledLatticeTilingDimensions( tiling[isemi] ) );

  // Get frequency spacing used by parameter-space tiling
  // - XLALEqualizeReducedSuperskyMetricsFreqSpacing() ensures this is the same for all segments
  const double dfreq = XLALLatticeTilingStepSizes( tiling[isemi], ndim - 1 );

  // Count approximate number of semicoherent templates
  {
    LogPrintf( LOG_NORMAL, "Counting approximate number of semicoherent templates ...\n" );
    const LatticeTilingStats *stats = XLALLatticeTilingStatistics( tiling[isemi], ndim - 1 );
    XLAL_CHECK_MAIN( stats != NULL, XLAL_EFUNC );
    LogPrintf( LOG_NORMAL, "Counted ~%" LAL_UINT8_FORMAT " semicoherent templates\n", stats->total_points );
  }

  ////////// Load input data //////////

  // Load or generate SFTs, unless search is being simulated
  SFTCatalog *sft_catalog = NULL;
  if ( UVAR_SET( sft_files ) ) {

    // Load SFT catalog from files given by 'sft_files'
    LogPrintf( LOG_NORMAL, "Loading SFTs matching '%s' into catalog ...\n", uvar->sft_files );
    sft_catalog = XLALSFTdataFind( uvar->sft_files, NULL );
    XLAL_CHECK_MAIN( sft_catalog != NULL, XLAL_EFUNC );
    XLAL_CHECK_MAIN( sft_catalog->length > 0, XLAL_EFUNC );
    LogPrintf( LOG_NORMAL, "Loaded SFT catalog from SFTs matching '%s'\n", uvar->sft_files );

  } else if ( UVAR_SET( sft_timebase ) ) {

    // Create timestamps for generated SFTs
    MultiLIGOTimeGPSVector *sft_timestamps = NULL;
    if ( UVAR_SET( sft_timestamps_files ) ) {

      // Check that the number of SFT timestamp files is consistent with the number of detectors
      XLAL_CHECK_MAIN( uvar->sft_timestamps_files->length == ndetectors, XLAL_EINVAL, "Number SFT timestamp files (%i) is inconsistent with number of detectors (%i) in setup file '%s'", uvar->sft_timestamps_files->length, ndetectors, uvar->setup_file );

      // Load SFT timestamps from files given by 'sft_timestamps_files'
      sft_timestamps = XLALReadMultiTimestampsFiles( uvar->sft_timestamps_files );
      XLAL_CHECK_MAIN( sft_timestamps != NULL, XLAL_EFUNC );
      for ( size_t i = 0; i < ndetectors; ++i ) {
        sft_timestamps->data[i]->deltaT = uvar->sft_timebase;
        LogPrintf( LOG_NORMAL, "Loaded SFT timestamps for detector '%s' from file '%s'\n", setup.detectors->data[i], uvar->sft_timestamps_files->data[i] );
      }

    } else {

      // Generate identical SFT timestamps for each detector, starting from beginning of segment list, with timebase given by 'sft_timebase'
      sft_timestamps = XLALMakeMultiTimestamps( segments_start, XLALGPSDiff( &segments_end, &segments_start ), uvar->sft_timebase, 0, ndetectors );
      XLAL_CHECK_MAIN( sft_timestamps != NULL, XLAL_EFUNC );
      LogPrintf( LOG_NORMAL, "Generated SFT timestamps for %i detectors, timebase = %.15g sec\n", ndetectors, uvar->sft_timebase );

    }

    // Generate SFT catalog for detectors 'sft_detectors' and timestamps 'sft_timestamps'
    sft_catalog = XLALMultiAddToFakeSFTCatalog( sft_catalog, setup.detectors, sft_timestamps );
    XLAL_CHECK_MAIN( sft_catalog != NULL, XLAL_EFUNC );
    XLAL_CHECK_MAIN( sft_catalog->length > 0, XLAL_EFUNC );

    // Cleanup
    XLALDestroyMultiTimestamps( sft_timestamps );

  }

  if ( sft_catalog != NULL ) {

    // Check that all SFT catalog detectors were included in metrics computed in setup file
    LALStringVector *sft_catalog_detectors = XLALListIFOsInCatalog( sft_catalog );
    XLAL_CHECK_MAIN( sft_catalog_detectors != NULL, XLAL_EFUNC );
    char *sft_catalog_detectors_string = XLALConcatStringVector( sft_catalog_detectors, "," );
    XLAL_CHECK_MAIN( sft_catalog_detectors_string != NULL, XLAL_EFUNC );
    XLAL_CHECK_MAIN( strcmp( sft_catalog_detectors_string, setup_detectors_string ) == 0, XLAL_EINVAL, "List of detectors '%s' in SFT catalog differs from list of detectors '%s' in setup file '%s'", sft_catalog_detectors_string, setup_detectors_string, uvar->setup_file );

    // Log number of SFTs, both in total and for each detector
    MultiSFTCatalogView *sft_catalog_view = XLALGetMultiSFTCatalogView( sft_catalog );
    XLAL_CHECK_MAIN( sft_catalog_view != NULL, XLAL_EINVAL );
    XLAL_CHECK_MAIN( sft_catalog_view->length > 0, XLAL_EFUNC );
    LogPrintf( LOG_NORMAL, "Using %u SFTs in total", sft_catalog->length );
    for ( size_t j = 0; j < sft_catalog_view->length; ++j ) {
      XLAL_CHECK_MAIN( sft_catalog_view->data[j].length > 0, XLAL_EFUNC );
      char *detector_name = XLALGetChannelPrefix( sft_catalog_view->data[j].data[0].header.name );
      XLAL_CHECK_MAIN( detector_name != NULL, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALFindStringInVector( detector_name, setup.detectors ) >= 0, XLAL_EFAILED );
      LogPrintfVerbatim( LOG_NORMAL, ", %u SFTs from detector '%s'", sft_catalog_view->data[j].length, detector_name );
      XLALFree( detector_name );
    }
    LogPrintfVerbatim( LOG_NORMAL, "\n" );

    // Cleanup
    XLALDestroyStringVector( sft_catalog_detectors );
    XLALFree( sft_catalog_detectors_string );
    XLALDestroyMultiSFTCatalogView( sft_catalog_view );

  }

  // Decide on search simulation level
  const WeaveSimulationLevel simulation_level = uvar->simulate_search ? ( WEAVE_SIMULATE | ( sft_catalog == NULL ? WEAVE_SIMULATE_MIN_MEM : 0 ) ) : 0;
  if ( simulation_level & WEAVE_SIMULATE ) {
    LogPrintf( LOG_NORMAL, "Simulating search with %s memory usage\n", simulation_level & WEAVE_SIMULATE_MIN_MEM ? "minimal" : "full" );
  }

  // Parse signal injection string
  PulsarParamsVector *injections = NULL;
  if ( UVAR_SET( injections ) ) {
    injections = XLALPulsarParamsFromUserInput( uvar->injections, &setup.ref_time );
    XLAL_CHECK_MAIN( injections != NULL, XLAL_EFUNC );
  }

  // Set F-statistic optional arguments
  Fstat_opt_args.randSeed = uvar->rand_seed;
  Fstat_opt_args.SSBprec = uvar->Fstat_SSB_precision;
  Fstat_opt_args.Dterms = uvar->Fstat_Dterms;
  Fstat_opt_args.runningMedianWindow = uvar->Fstat_run_med_window;
  Fstat_opt_args.FstatMethod = uvar->Fstat_method;
  Fstat_opt_args.injectSources = injections;
  Fstat_opt_args.prevInput = NULL;

  // Get timeslices of SFT catalogs restricted to each segment
  SFTCatalog XLAL_INIT_DECL( sft_catalog_seg, [nsegments] );
  UINT4 nsfts = 0;
  if ( sft_catalog != NULL ) {
    for ( size_t i = 0; i < nsegments; ++i ) {

      // Get a timeslice of SFT catalog restricted to 'i'th segment
      const LIGOTimeGPS *segment_start = &setup.segments->segs[i].start;
      const LIGOTimeGPS *segment_end = &setup.segments->segs[i].end;
      XLAL_CHECK_MAIN( XLALSFTCatalogTimeslice( &sft_catalog_seg[i], sft_catalog, segment_start, segment_end ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( sft_catalog_seg[i].length > 0, XLAL_EINVAL, "No SFTs found for segment %zu", i );

      // Count total number of SFTs used by search
      nsfts += sft_catalog_seg[i].length;

      // Record information on SFTs in catalog
      MultiSFTCatalogView *sft_catalog_seg_i_view = XLALGetMultiSFTCatalogView( &sft_catalog_seg[i] );
      XLAL_CHECK_MAIN( sft_catalog_seg_i_view != NULL, XLAL_EINVAL );
      for ( size_t j = 0; j < sft_catalog_seg_i_view->length; ++j ) {
        XLAL_CHECK_MAIN( sft_catalog_seg_i_view->data[j].length > 0, XLAL_EINVAL, "No SFTs found for segment %zu, detector %zu", i, j );
        char *detector_name = XLALGetChannelPrefix( sft_catalog_seg_i_view->data[j].data[0].header.name );
        XLAL_CHECK_MAIN( detector_name != NULL, XLAL_EFUNC );
        const int k = XLALFindStringInVector( detector_name, setup.detectors );
        if ( k >= 0 ) {
          const UINT4 length = sft_catalog_seg_i_view->data[j].length;
          per_seg_info[i].sft_first[k] = sft_catalog_seg_i_view->data[j].data[0].header.epoch;
          per_seg_info[i].sft_last[k] = sft_catalog_seg_i_view->data[j].data[length - 1].header.epoch;
          per_seg_info[i].sft_count[k] = length;
        }
        XLALFree( detector_name );
      }

      // Cleanup
      XLALDestroyMultiSFTCatalogView( sft_catalog_seg_i_view );

    }
  }

  // Validate SFTs within segment-restricted catalogs, if requested
  if ( sft_catalog != NULL && uvar->validate_sft_files ) {
    LogPrintf( LOG_NORMAL, "Validating SFTs ...\n" );

    // Validate checksums of SFTs, if requested
    if ( UVAR_SET( sft_files ) ) {
      for ( size_t i = 0; i < nsegments; ++i ) {
        BOOLEAN crc_check = 0;
        XLAL_CHECK_MAIN( XLALCheckCRCSFTCatalog( &crc_check, &sft_catalog_seg[i] ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK_MAIN( crc_check, XLAL_EFUNC, "Failed to validate checksums of SFTs in segment %zu\n", i );
      }
    }

    // Check that the number of SFTs in each segment matches the number provided by the segment list in the setup file, if requested
    for ( size_t i = 0; i < nsegments; ++i ) {
      const UINT4 sft_count = ( UINT4 ) setup.segments->segs[i].id;
      XLAL_CHECK_MAIN( sft_count > 0, XLAL_EFAILED, "No number of SFTs given for segment %zu in setup file '%s'", i, uvar->setup_file );
      XLAL_CHECK_MAIN( sft_catalog_seg[i].length == sft_count, XLAL_EFAILED, "Number of SFTs found for segment %zu (%u) is inconsistent with expected number of SFTs given by segment list (%u) in setup file '%s'", i, sft_catalog_seg[i].length, sft_count, uvar->setup_file );
    }

    // Validation complete
    LogPrintf( LOG_NORMAL, "Finished validating SFTs\n" );

  }

  // Load input data required for computing coherent results
  WeaveCohInput *XLAL_INIT_DECL( coh_input, [nsegments] );
  const char *Fstat_method_name = NULL;
  LogPrintf( LOG_NORMAL, "Loading input data for coherent results ...\n" );
  for ( size_t i = 0; i < nsegments; ++i ) {

    // Load F-statistic input data for 'i'th segment
    FstatInput *Fstat_input = NULL;
    if ( sft_catalog != NULL ) {

      // Get list of detectors of SFT catalog in 'i'th segment
      LALStringVector *sft_catalog_seg_i_detectors = XLALListIFOsInCatalog( &sft_catalog_seg[i] );
      XLAL_CHECK_MAIN( sft_catalog_seg_i_detectors != NULL, XLAL_EFUNC );

      // Get spindown range covered by parameter-space tiling of 'i'th segment
      PulsarSpinRange XLAL_INIT_DECL( spin_range );
      XLAL_CHECK_MAIN( XLALSuperskyLatticePulsarSpinRange( &spin_range, tiling[i], rssky_transf[i] ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Compute frequency range covered by spindown range over 'i'th segment
      LIGOTimeGPS sft_start = sft_catalog_seg[i].data[0].header.epoch;
      LIGOTimeGPS sft_end = sft_catalog_seg[i].data[sft_catalog_seg[i].length - 1].header.epoch;
      const double sft_end_timebase = 1.0 / sft_catalog_seg[i].data[sft_catalog_seg[i].length - 1].header.deltaF;
      XLALGPSAdd( &sft_end, sft_end_timebase );
      double sft_min_cover_freq = 0, sft_max_cover_freq = 0;
      XLAL_CHECK_MAIN( XLALCWSignalCoveringBand( &sft_min_cover_freq, &sft_max_cover_freq, &sft_start, &sft_end, &spin_range, 0, 0, 0 ) == XLAL_SUCCESS, XLAL_EFUNC );
      per_seg_info[i].sft_min_cover_freq = sft_min_cover_freq;
      per_seg_info[i].sft_max_cover_freq = sft_max_cover_freq;

      // Parse SFT noise PSD string vector
      MultiNoiseFloor sft_noise_psd;
      if ( UVAR_SET( sft_noise_psd ) ) {
        XLAL_CHECK_MAIN( XLALParseMultiNoiseFloorMapped( &sft_noise_psd, sft_catalog_seg_i_detectors, uvar->sft_noise_psd, setup.detectors ) == XLAL_SUCCESS, XLAL_EFUNC );
        Fstat_opt_args.injectSqrtSX = &sft_noise_psd;
      }

      // Parse F-statistic assumed PSD string vector
      MultiNoiseFloor Fstat_assume_psd;
      if ( UVAR_SET( Fstat_assume_psd ) ) {
        XLAL_CHECK_MAIN( XLALParseMultiNoiseFloorMapped( &Fstat_assume_psd, sft_catalog_seg_i_detectors, uvar->Fstat_assume_psd, setup.detectors ) == XLAL_SUCCESS, XLAL_EFUNC );
        Fstat_opt_args.assumeSqrtSX = &Fstat_assume_psd;
      }

      // Load F-statistic input data
      Fstat_input = XLALCreateFstatInput( &sft_catalog_seg[i], sft_min_cover_freq, sft_max_cover_freq, dfreq, setup.ephemerides, &Fstat_opt_args );
      XLAL_CHECK_MAIN( Fstat_input != NULL, XLAL_EFUNC );
      Fstat_opt_args.prevInput = Fstat_input;

      // Get F-statistic method name
      if ( Fstat_method_name == NULL ) {
        Fstat_method_name = XLALGetFstatInputMethodName( Fstat_input );
        XLAL_CHECK_MAIN( Fstat_method_name != NULL, XLAL_EFUNC );
      }

      // Cleanup
      XLALDestroyStringVector( sft_catalog_seg_i_detectors );

    }

    // Load coherent input data for 'i'th segment
    coh_input[i] = XLALWeaveCohInputCreate( simulation_level, Fstat_input, per_detectors );
    XLAL_CHECK_MAIN( coh_input[i] != NULL, XLAL_EFUNC );

  }
  LogPrintf( LOG_NORMAL, "Finished loading input data for coherent results\n" );

  // Create caches to store intermediate results from coherent parameter-space tilings
  // - If no interpolation, caching is not required so reduce maximum cache size to 1
  WeaveCache *XLAL_INIT_DECL( coh_cache, [nsegments] );
  for ( size_t i = 0; i < nsegments; ++i ) {
    const size_t cache_max_size = interpolation ? uvar->cache_max_size : 1;
    const size_t cache_gc_limit = interpolation ? uvar->cache_gc_limit : 0;
    coh_cache[i] = XLALWeaveCacheCreate( tiling[i], interpolation, setup.phys_to_latt, setup.latt_to_phys, rssky_transf[i], rssky_transf[isemi], coh_input[i], cache_max_size, cache_gc_limit, uvar->misc_info );
    XLAL_CHECK_MAIN( coh_cache[i] != NULL, XLAL_EFUNC );
  }

  ////////// Perform search //////////

  // Create iterator over semicoherent tiling
  // - The last parameter-space dimension is always frequency and is not iterated over, since we
  //   always operate over a block of frequencies at once. Since the frequency spacing is always
  //   equal over all tilings due to XLALEqualizeReducedSuperskyMetricsFreqSpacing(), operations
  //   such as nearest point finding can be performed once per frequency block instead of per bin.
  LatticeTilingIterator *semi_itr = XLALCreateLatticeTilingIterator( tiling[isemi], ndim - 1 );
  XLAL_CHECK_MAIN( semi_itr != NULL, XLAL_EFUNC );
  gsl_vector *GAVEC_MAIN( semi_rssky, ndim );

  // Create storage for cache queries for coherent results in each segment
  WeaveCacheQueries *queries = XLALWeaveCacheQueriesCreate( tiling[isemi], setup.phys_to_latt, setup.latt_to_phys, rssky_transf[isemi], nsegments, uvar->freq_partitions );
  XLAL_CHECK_MAIN( queries != NULL, XLAL_EFUNC );

  // Pointer to partial and final semicoherent results
  WeaveSemiPartials *semi_parts = NULL;
  WeaveSemiResults *semi_res = NULL;

  // Create output results structure
  WeaveOutputResults *out = XLALWeaveOutputResultsCreate( &setup.ref_time, ninputspins, per_detectors, per_nsegments, uvar->toplists, uvar->toplist_limit );
  XLAL_CHECK_MAIN( out != NULL, XLAL_EFUNC );

  // Number of times output results have been restored from a checkpoint
  UINT4 ckpt_output_count = 0;

  // Number of computed coherent and semicoherent results
  UINT8 coh_nfbk = 0, coh_nres = 0, semi_nres = 0;

  // Semicoherent frequency block count and index
  const UINT8 freq_block_count = XLALTotalLatticeTilingPoints( semi_itr );
  XLAL_CHECK_MAIN( freq_block_count > 0, XLAL_EFUNC );
  UINT8 freq_block_index = 0;

  // Partition index
  UINT4 partition_index = 0;

  // Try to restore output results from a checkpoint file, if given
  if ( UVAR_SET( ckpt_output_file ) ) {

    // Try to open output checkpoint file
    LogPrintf( LOG_NORMAL, "Trying to open output checkpoint file '%s' for reading ...\n", uvar->ckpt_output_file );
    int errnum = 0;
    FITSFile *file = NULL;
    XLAL_TRY( file = XLALFITSFileOpenRead( uvar->ckpt_output_file ), errnum );
    if ( errnum == XLAL_ENOENT ) {
      LogPrintf( LOG_NORMAL, "Output checkpoint file '%s' does not exist; no checkpoint will be loaded\n", uvar->ckpt_output_file );
    } else {
      XLAL_CHECK_MAIN( errnum == 0 && file != NULL, XLAL_EFUNC );
      LogPrintf( LOG_NORMAL, "Output checkpoint file '%s' exists; checkpoint will be loaded\n", uvar->ckpt_output_file );

      // Read number of times output results have been restored from a checkpoint
      XLAL_CHECK_MAIN( XLALFITSHeaderReadUINT4( file, "ckptcnt", &ckpt_output_count ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( ckpt_output_count > 0, XLAL_EIO, "Invalid output checkpoint file '%s'", uvar->ckpt_output_file );

      // Read number of computed coherent and semicoherent results
      XLAL_CHECK_MAIN( XLALFITSHeaderReadUINT8( file, "ncohfbk", &coh_nfbk ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALFITSHeaderReadUINT8( file, "ncohres", &coh_nres ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALFITSHeaderReadUINT8( file, "nsemires", &semi_nres ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Read output results
      XLAL_CHECK_MAIN( XLALWeaveOutputResultsReadAppend( file, &out ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Read state of iterator over semicoherent tiling
      XLAL_CHECK_MAIN( XLALRestoreLatticeTilingIterator( semi_itr, file, "semi_itr" ) == XLAL_SUCCESS, XLAL_EFUNC );
      freq_block_index = XLALCurrentLatticeTilingIndex( semi_itr );
      XLAL_CHECK_MAIN( freq_block_index < freq_block_count, XLAL_EIO, "Invalid output checkpoint file '%s'", uvar->ckpt_output_file );

      // Read partition index
      XLAL_CHECK_MAIN( XLALFITSHeaderReadUINT4( file, "partindx", &partition_index ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( partition_index < uvar->freq_partitions, XLAL_EIO, "Invalid output checkpoint file '%s'", uvar->ckpt_output_file );

      // Close output checkpoint file
      XLALFITSFileClose( file );
      LogPrintf( LOG_NORMAL, "Closed output checkpoint file '%s'\n", uvar->ckpt_output_file );

    }

  }

  // Initial wall and CPU times
  const double wall_zero = wall_time();
  const double cpu_zero = cpu_time();

  // Time taken during various sections of the main search loop
  double cpu_timing_coh_res = 0;
  double cpu_timing_semi_parts = 0;
  double cpu_timing_semi_res = 0;
  double cpu_timing_output = 0;

  // Time at which search was last checkpointed
  double wall_ckpt_output = wall_zero;

  // Time at which progress was last printed, and interval at which to print progress
  double wall_prog = wall_zero;
  double wall_prog_period = 5.0;

  // Whether to print predicted remaining time, and previous prediction for total elapsed time
  BOOLEAN wall_prog_remain_print = 0;
  double wall_prog_total_prev = 0;

  // Print initial progress in frequency blocks and partitions
  const UINT8 prog_count = uvar->freq_partitions * freq_block_count;
  {
    const UINT8 prog_index = partition_index * freq_block_count + freq_block_index;
    const double prog_per_cent = 100.0 * prog_index / prog_count;
    LogPrintf( LOG_NORMAL, "Starting main search loop at %" LAL_UINT8_FORMAT "/%" LAL_UINT8_FORMAT " frequency blocks (%.1f%%)", prog_index, prog_count, prog_per_cent );
    if ( uvar->freq_partitions > 1 ) {
      LogPrintfVerbatim( LOG_NORMAL, ", partition %i/%i", partition_index, uvar->freq_partitions );
    }
    LogPrintfVerbatim( LOG_NORMAL, ", peak memory %.1fMB\n", XLALGetPeakHeapUsageMB() );
  }

#ifdef WEAVE_CALLGRIND   // Set when compiling lalapps_Weave_Callgrind
  // Start profiling before main search loop
  CALLGRIND_START_INSTRUMENTATION;
  CALLGRIND_ZERO_STATS;
#endif

  // Begin main search loop
  BOOLEAN search_complete = 0;
  while ( !search_complete ) {

    // Get mid-point of the next semicoherent frequency block
    // - XLALNextLatticeTilingPoint() returns mid-point in non-iterated dimensions
    const int itr_retn = XLALNextLatticeTilingPoint( semi_itr, semi_rssky );
    XLAL_CHECK_MAIN( itr_retn >= 0, XLAL_EFUNC );
    if ( itr_retn == 0 ) {

      // Move to the next partition
      ++partition_index;
      freq_block_index = 0;
      if ( partition_index == uvar->freq_partitions ) {

        // Search is complete
        search_complete = 1;
        continue;

      }

      // Reset iterator over semicoherent tiling
      XLAL_CHECK_MAIN( XLALResetLatticeTilingIterator( semi_itr ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALNextLatticeTilingPoint( semi_itr, semi_rssky ) > 0, XLAL_EFUNC );

    }

    // Initialise cache queries
    XLAL_CHECK_MAIN( XLALWeaveCacheQueriesInit( queries, semi_itr, semi_rssky ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Query for coherent results for each segment
    for ( size_t i = 0; i < nsegments; ++i ) {
      XLAL_CHECK_MAIN( XLALWeaveCacheQuery( coh_cache[i], freq_block_index, queries, i ) == XLAL_SUCCESS, XLAL_EFUNC );
    }

    // Finalise cache queries
    PulsarDopplerParams XLAL_INIT_DECL( semi_phys );
    UINT4 semi_nfreqs = 0;
    XLAL_CHECK_MAIN( XLALWeaveCacheQueriesFinal( queries, partition_index, &semi_phys, dfreq, &semi_nfreqs ) == XLAL_SUCCESS, XLAL_EFUNC );
    if ( semi_nfreqs > 0 ) {

      // Initialise partial semicoherent results
      XLAL_CHECK_MAIN( XLALWeaveSemiPartialsInit( &semi_parts, simulation_level, ndetectors, nsegments, &semi_phys, dfreq, semi_nfreqs ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Start timing
      double cpu_timing_tic = cpu_time();
      double cpu_timing_toc = 0;

      // Retrieve coherent results from each segment
      const WeaveCohResults *XLAL_INIT_DECL( coh_res, [nsegments] );
      UINT4 XLAL_INIT_DECL( coh_offset, [nsegments] );
      for ( size_t i = 0; i < nsegments; ++i ) {
        XLAL_CHECK_MAIN( XLALWeaveCacheRetrieve( coh_cache[i], queries, i, &coh_res[i], &coh_offset[i], &coh_nfbk, &coh_nres, &per_seg_info[i].coh_n1comp, &per_seg_info[i].coh_nrecomp ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK_MAIN( coh_res[i] != NULL, XLAL_EFUNC );
      }

      // Time computation of coherent results
      cpu_timing_toc = cpu_time();
      cpu_timing_coh_res += cpu_timing_toc - cpu_timing_tic;
      cpu_timing_tic = cpu_timing_toc;

      // Add coherent results to partial semicoherent results
      for ( size_t i = 0; i < nsegments; ++i ) {
        XLAL_CHECK_MAIN( XLALWeaveSemiPartialsAdd( semi_parts, coh_res[i], coh_offset[i] ) == XLAL_SUCCESS, XLAL_EFUNC );
      }

      // Time computation of partial semicoherent results
      cpu_timing_toc = cpu_time();
      cpu_timing_semi_parts += cpu_timing_toc - cpu_timing_tic;
      cpu_timing_tic = cpu_timing_toc;

      // Compute final semicoherent results
      XLAL_CHECK_MAIN( XLALWeaveSemiResultsCompute( &semi_res, semi_parts ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Time computation of final semicoherent results
      cpu_timing_toc = cpu_time();
      cpu_timing_semi_res += cpu_timing_toc - cpu_timing_tic;
      cpu_timing_tic = cpu_timing_toc;

      // Add semicoherent results to output
      XLAL_CHECK_MAIN( XLALWeaveOutputResultsAdd( out, semi_res, semi_nfreqs ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Time output of semicoherent results
      cpu_timing_toc = cpu_time();
      cpu_timing_output += cpu_timing_toc - cpu_timing_tic;
      cpu_timing_tic = cpu_timing_toc;

      // Increment number of computed semicoherent results
      semi_nres += semi_nfreqs;

    }

    // Increment semicoherent frequency block index
    ++freq_block_index;

    // Progress index and percentage complete
    const UINT8 prog_index = partition_index * freq_block_count + freq_block_index;
    const double prog_per_cent = 100.0 * prog_index / prog_count;

    // Current wall and CPU times
    const double wall_now = wall_time();
    const double cpu_now = cpu_time();

    // Checkpoint output results, if required
    if ( UVAR_SET( ckpt_output_file ) ) {

      // Decide whether to checkpoint output results
      const BOOLEAN do_ckpt_output_period = UVAR_SET( ckpt_output_period ) && wall_now - wall_ckpt_output >= uvar->ckpt_output_period;
      const BOOLEAN do_ckpt_output_exit = UVAR_SET( ckpt_output_exit ) && prog_per_cent >= 100.0 * uvar->ckpt_output_exit;
      if ( do_ckpt_output_period || do_ckpt_output_exit ) {

        // Open output checkpoint file
        FITSFile *file = XLALFITSFileOpenWrite( uvar->ckpt_output_file );
        XLAL_CHECK_MAIN( file != NULL, XLAL_EFUNC );
        XLAL_CHECK_MAIN( XLALFITSFileWriteVCSInfo( file, lalAppsVCSInfoList ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK_MAIN( XLALFITSFileWriteUVarCmdLine( file ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Write number of times output results have been restored from a checkpoint
        ++ckpt_output_count;
        XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT4( file, "ckptcnt", ckpt_output_count, "number of checkpoints" ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Write number of computed coherent and semicoherent results
        XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT8( file, "ncohfbk", coh_nfbk, "number of computed coherent frequency blocks" ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT8( file, "ncohres", coh_nres, "number of computed coherent results" ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT8( file, "nsemires", semi_nres, "number of computed semicoherent results" ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Write output results
        XLAL_CHECK_MAIN( XLALWeaveOutputResultsWrite( file, out ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Write state of iterator over semicoherent tiling
        XLAL_CHECK_MAIN( XLALSaveLatticeTilingIterator( semi_itr, file, "semi_itr" ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Write partition index
        XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT4( file, "partindx", partition_index, "partition index" ) == XLAL_SUCCESS, XLAL_EFUNC );

        // Close output checkpoint file
        XLALFITSFileClose( file );

        // Print progress
        LogPrintf( LOG_NORMAL, "Wrote output checkpoint to file '%s' after %.1f time elapsed, %" LAL_UINT8_FORMAT " frequency blocks\n", uvar->ckpt_output_file, wall_now - wall_zero, freq_block_index );

        // Exit main search loop, if checkpointing was triggered by 'do_ckpt_output_exit'
        if ( do_ckpt_output_exit ) {
          LogPrintf( LOG_NORMAL, "Exiting main seach loop after writing output checkpoint\n" );
          break;
        }

        // Update time at which search was last checkpointed
        wall_ckpt_output = wall_now;

      }

    }

    // Print iteration progress, if required
    if ( wall_now - wall_prog >= wall_prog_period ) {
      const double wall_elapsed = wall_now - wall_zero;
      const double cpu_elapsed = cpu_now - cpu_zero;

      // Print whether search is being simulated
      LogPrintf( LOG_NORMAL, "%s", simulation_level & WEAVE_SIMULATE ? "Simulated" : "Searched" );

      // Print progress in frequency blocks and partitions
      LogPrintfVerbatim( LOG_NORMAL, " %" LAL_UINT8_FORMAT "/%" LAL_UINT8_FORMAT " frequency blocks (%.1f%%)", prog_index, prog_count, prog_per_cent );
      if ( uvar->freq_partitions > 1 ) {
        LogPrintfVerbatim( LOG_NORMAL, ", partition %i/%i", partition_index, uvar->freq_partitions );
      }

      // Print elapsed time
      LogPrintfVerbatim( LOG_NORMAL, ", elapsed %.1f sec", wall_now - wall_zero );

      // Print remaining time, if it can be reliably predicted
      const double wall_prog_remain = wall_elapsed * ( prog_count - prog_index ) / prog_index;
      const double wall_prog_total = wall_elapsed + wall_prog_remain;
      if ( wall_prog_remain_print || fabs( wall_prog_total - wall_prog_total_prev ) <= 0.1 * wall_prog_total_prev ) {
        LogPrintfVerbatim( LOG_NORMAL, ", remaining ~%.1f sec", wall_prog_remain );
        wall_prog_remain_print = 1;   // Always print remaining time once it can be reliably predicted
      } else {
        wall_prog_total_prev = wall_prog_total;
      }

      // Print CPU usage
      LogPrintfVerbatim( LOG_NORMAL, ", CPU %.1f%%", 100.0 * cpu_elapsed / wall_elapsed );

      // Print memory usage
      LogPrintfVerbatim( LOG_NORMAL, ", peak memory %.1fMB", XLALGetPeakHeapUsageMB() );

      // Finish progress printing
      LogPrintfVerbatim( LOG_NORMAL, "\n" );

      // Update time at which progress was last printed, and increase interval at which to print progress
      wall_prog = wall_now;
      wall_prog_period = GSL_MIN( 1200, wall_prog_period * 1.5 );

    }

  }   // End of main search loop

#ifdef WEAVE_CALLGRIND   // Set when compiling lalapps_Weave_Callgrind
  // Stop profiling and dump statistics after main search loop
  CALLGRIND_STOP_INSTRUMENTATION;
  CALLGRIND_DUMP_STATS_AT("main search loop");
#endif

  // Total elapsed wall and CPU times
  const double wall_total = wall_time() - wall_zero;
  const double cpu_total = cpu_time() - cpu_zero;

  // Print final progress in frequency blocks and partitions
  {
    const UINT8 prog_index = partition_index * freq_block_count + freq_block_index;
    const double prog_per_cent = 100.0 * prog_index / prog_count;
    LogPrintf( LOG_NORMAL, "Finished main search loop at %" LAL_UINT8_FORMAT "/%" LAL_UINT8_FORMAT " frequency blocks (%.1f%%)", prog_index, prog_count, prog_per_cent );
    if ( uvar->freq_partitions > 1 ) {
      LogPrintfVerbatim( LOG_NORMAL, ", partition %i/%i", partition_index, uvar->freq_partitions );
    }
    LogPrintfVerbatim( LOG_NORMAL, ", total %.1f sec, CPU %.1f%%, peak memory %.1fMB\n", wall_total, 100.0 * cpu_total / wall_total, XLALGetPeakHeapUsageMB() );
  }

  // Elapsed time not accounted for by the various timed sections of the main search loop
  const double cpu_timing_other = cpu_total - cpu_timing_coh_res - cpu_timing_semi_parts - cpu_timing_semi_res - cpu_timing_output;

  ////////// Output search results //////////

  if ( search_complete ) {

    // Open output file
    LogPrintf( LOG_NORMAL, "Opening output file '%s' for writing ...\n", uvar->output_file );
    FITSFile *file = XLALFITSFileOpenWrite( uvar->output_file );
    XLAL_CHECK_MAIN( file != NULL, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSFileWriteVCSInfo( file, lalAppsVCSInfoList ) == XLAL_SUCCESS, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSFileWriteUVarCmdLine( file ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Write number of times output results were restored from a checkpoint
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT4( file, "numckpt", ckpt_output_count, "number of checkpoints" ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Write list of detectors
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteStringVector( file, "detect", setup.detectors, "setup detectors" ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Write number of segments
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT4( file, "nsegment", nsegments, "number of segments" ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Write total number of SFTs used by search
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT4( file, "nsfts", nsfts, "number of SFTs used by search" ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Write physical parameter-space ranges
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "minrng alpha [rad]", ps[psialpha][0], "minimum right ascension range" ) == XLAL_SUCCESS, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "maxrng alpha [rad]", ps[psialpha][1], "maximum right ascension range" ) == XLAL_SUCCESS, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "minrng delta [rad]", ps[psidelta][0], "minimum declination range" ) == XLAL_SUCCESS, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "maxrng delta [rad]", ps[psidelta][1], "maximum declination range" ) == XLAL_SUCCESS, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "minrng freq [Hz]", ps[psifreq][0], "minimum frequency range" ) == XLAL_SUCCESS, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "maxrng freq [Hz]", ps[psifreq][1], "maximum frequency range" ) == XLAL_SUCCESS, XLAL_EFUNC );
    for ( size_t s = 1; s <= ninputspins; ++s ) {
      char keyword[64];
      char comment[64];
      snprintf( keyword, sizeof( keyword ), "minrng f%zudot [Hz/s^%zu]", s, s );
      snprintf( comment, sizeof( comment ), "minimum %zu-order spindown range", s );
      XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, keyword, ps[psifreq+s][0], comment ) == XLAL_SUCCESS, XLAL_EFUNC );
      snprintf( keyword, sizeof( keyword ), "maxrng f%zudot [Hz/s^%zu]", s, s );
      snprintf( comment, sizeof( comment ), "maximum %zu-order spindown range", s );
      XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, keyword, ps[psifreq+s][1], comment ) == XLAL_SUCCESS, XLAL_EFUNC );
    }

    // Write frequency spacing
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "dfreq", dfreq, "frequency spacing" ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Write average number of semicoherent templates per each dimension
    {
      char keyword[64];
      double avg_points_denom = 1;
      for ( size_t i = 0; i < ndim; ++i ) {
        const LatticeTilingStats *semi_stats = XLALLatticeTilingStatistics( tiling[isemi], i );
        XLAL_CHECK_MAIN( semi_stats != NULL, XLAL_EFUNC );
        XLAL_CHECK_MAIN( semi_stats->name != NULL, XLAL_EFUNC );
        XLAL_CHECK_MAIN( semi_stats->total_points > 0, XLAL_EFUNC );
        UINT4 avg_points = lround( semi_stats->total_points / avg_points_denom );
        snprintf( keyword, sizeof( keyword ), "semiavg %s", semi_stats->name );
        XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT4( file, keyword, avg_points, "average number of templates in dimension" ) == XLAL_SUCCESS, XLAL_EFUNC );
        avg_points_denom = semi_stats->total_points;
      }
    }

    // Write number of computed coherent and semicoherent results
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT8( file, "ncohfbk", coh_nfbk, "number of computed coherent frequency blocks" ) == XLAL_SUCCESS, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT8( file, "ncohres", coh_nres, "number of computed coherent results" ) == XLAL_SUCCESS, XLAL_EFUNC );
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteUINT8( file, "nsemires", semi_nres, "number of computed semicoherent results" ) == XLAL_SUCCESS, XLAL_EFUNC );

    // Write peak memory usage
    XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "peakmem [MB]", XLALGetPeakHeapUsageMB(), "peak memory usage" ) == XLAL_SUCCESS, XLAL_EFUNC );

    if ( simulation_level == 0 ) {   // Unless search is being simulated...

      // Write F-statistic method name
      XLAL_CHECK_MAIN( XLALFITSHeaderWriteString( file, "fmethod", Fstat_method_name, "name of F-statistic method" ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Write timing information
      XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "wall total", wall_total, "total wall time" ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "cpu total", cpu_total, "total CPU time" ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "cpu cohres", cpu_timing_coh_res, "CPU time taken to compute coherent results" ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "cpu semiparts", cpu_timing_semi_parts, "CPU time taken to compute partial semicoherent results" ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "cpu semires", cpu_timing_semi_res, "CPU time taken to compute final semicoherent results" ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "cpu output", cpu_timing_output, "CPU time taken to output semicoherent results" ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK_MAIN( XLALFITSHeaderWriteREAL8( file, "cpu other", cpu_timing_other, "CPU time unaccounted for" ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Write search results
      XLAL_CHECK_MAIN( XLALWeaveOutputResultsWrite( file, out ) == XLAL_SUCCESS, XLAL_EFUNC );

    }

    // Write miscellaneous per-segment information
    if ( uvar->misc_info ) {

      // Begin FITS table
      XLAL_CHECK( XLALFITSTableOpenWrite( file, "per_seg_info", "miscellaneous per-segment information" ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Describe FITS table
      char col_name[64];
      XLAL_FITS_TABLE_COLUMN_BEGIN( misc_per_seg_info );
      XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, GPSTime, segment_start ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, GPSTime, segment_end ) == XLAL_SUCCESS, XLAL_EFUNC );
      if ( sft_catalog != NULL ) {
        for ( size_t i = 0; i < setup.detectors->length; ++i ) {
          snprintf( col_name, sizeof( col_name ), "sft_first_%s", setup.detectors->data[i] );
          XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD_NAMED( file, GPSTime, sft_first[i], col_name ) == XLAL_SUCCESS, XLAL_EFUNC );
          snprintf( col_name, sizeof( col_name ), "sft_last_%s", setup.detectors->data[i] );
          XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD_NAMED( file, GPSTime, sft_last[i], col_name ) == XLAL_SUCCESS, XLAL_EFUNC );
          snprintf( col_name, sizeof( col_name ), "sft_count_%s", setup.detectors->data[i] );
          XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD_NAMED( file, UINT4, sft_count[i], col_name ) == XLAL_SUCCESS, XLAL_EFUNC );
        }
        XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, REAL8, sft_min_cover_freq ) == XLAL_SUCCESS, XLAL_EFUNC );
        XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, REAL8, sft_max_cover_freq ) == XLAL_SUCCESS, XLAL_EFUNC );
      }
      XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, UINT4, coh_n1comp ) == XLAL_SUCCESS, XLAL_EFUNC );
      XLAL_CHECK( XLAL_FITS_TABLE_COLUMN_ADD( file, UINT4, coh_nrecomp ) == XLAL_SUCCESS, XLAL_EFUNC );

      // Write FITS table
      for ( size_t i = 0; i < nsegments; ++i ) {
        XLAL_CHECK( XLALFITSTableWriteRow( file, &per_seg_info[i] ) == XLAL_SUCCESS, XLAL_EFUNC );
      }

    }

    // Close output file
    XLALFITSFileClose( file );
    LogPrintf( LOG_NORMAL, "Closed output file '%s'\n", uvar->output_file );
  }

  ////////// Cleanup memory and exit //////////

  // Cleanup memory from output results
  XLALWeaveOutputResultsDestroy( out );

  // Cleanup memory from semicoherent results
  XLALWeaveSemiPartialsDestroy( semi_parts );
  XLALWeaveSemiResultsDestroy( semi_res );

  // Cleanup memory from parameter-space iteration
  XLALDestroyLatticeTilingIterator( semi_itr );

  // Cleanup memory from computing coherent results
  XLALWeaveCacheQueriesDestroy( queries );
  for ( size_t i = 0; i < nsegments; ++i ) {
    XLALWeaveCacheDestroy( coh_cache[i] );
  }
  for ( size_t i = 0; i < nsegments; ++i ) {
    XLALWeaveCohInputDestroy( coh_input[i] );
  }

  // Cleanup memory from loading input data
  XLALDestroySFTCatalog( sft_catalog );

  // Cleanup memory from lattice tilings
  for ( size_t i = 0; i < ntiles; ++i ) {
    XLALDestroyLatticeTiling( tiling[i] );
  }

  // Cleanup memory from setup data
  XLALWeaveSetupDataClear( &setup );
  XLALFree( setup_detectors_string );

  // Cleanup memory from user input
  XLALDestroyUserVars();
  XLALDestroyPulsarParamsVector( injections );

  // Check for memory leaks
  LALCheckMemoryLeaks();

  if ( search_complete ) {
    LogPrintf( LOG_NORMAL, "Finished successfully!\n" );
  } else {
    LogPrintf( LOG_NORMAL, "Finished but search not completed!\n" );
  }

  return EXIT_SUCCESS;

}

// Local Variables:
// c-file-style: "linux"
// c-basic-offset: 2
// End:

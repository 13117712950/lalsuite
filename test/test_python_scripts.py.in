#!/usr/bin/env python
#
# Test --help for all python scripts

import os
import sys
import warnings
try:
    from pathlib import Path
except ImportError as exc:
    warnings.warn(str(exc))
    sys.exit(77)
from subprocess import check_call
try:
    from unittest import mock
except ImportError:  # python < 3
    import mock
    FileNotFoundError = IOError

import pytest

try:
    FileNotFoundError
except NameError:  # python < 3
    FileNotFoundError = IOError

# are we currently in the TEST phase of a conda build?
CONDA_BUILD_TEST = os.getenv("CONDA_BUILD_STATE") == "TEST"

# find python scripts directory
# NOTE: we do this using relative paths as a hack to allow
#       conda-build to copy this file and the /python/Makefile
#       from the src tree and have the tests still work
HERE = Path(__file__).parent.absolute()
BUILDDIR = (HERE / Path("@builddir@")).resolve()
SRCDIR = (HERE / Path("@srcdir@")).resolve()
TOPDIR = (HERE / Path("@top_builddir@")).resolve()
if "@PACKAGE_NAME_LCASE@" == "lalapps":  # lalapps is different
    PYTHONDIR = BUILDDIR
else:
    PYTHONDIR = TOPDIR / "python"


def _ignore_symlinks(self):
    """Patch function for py._path.local.LocalPath.realpath

    LALSuite symlinks _this_ script into multiple subpackage directories,
    this function stops pytest from automatically resolving the symlink
    back to the absolute path, since we need this script to sit beside
    the relevant exclude files.
    """
    return self


def read_excludes(source):
    """Read all excluded file paths from the given source file
    """
    excludes = set()
    with open(str(source), "r") as fobj:
        for line in fobj:
            if isinstance(line, bytes):
                line = line.decode("utf-8")
            content = line.strip().split("#", 1)[0].strip()
            if content:
                excludes.add(content)
    return excludes


def parse_pybin_scripts(path, var="pybin_scripts"):
    with path.open("r") as makefile:
        inscriptslist = False
        for line in makefile:
            line = line.rstrip()
            # starting the pybin_scripts list
            if line.startswith(var):
                inscriptslist = True
                # if given a value immediately, use it
                value = line.split("=", 1)[1].rstrip(" \\")
                if value:
                    yield value
            # ending the pybin_scripts list (or not in it)
            elif not line or line.endswith("$(END_OF_LIST)"):
                inscriptslist = False
            # otherwise we must be inside the list definition,
            # so yield its contents
            elif inscriptslist:
                yield line.rstrip("\\").strip()


def find_scripts(path):
    for pyf in path.glob("*.py"):
        # build system creates a shell wrapper around each .py script
        # so we want to actually execute that, this also allows us to
        # only pick up scripts that are to be installed
        shf = Path(str(pyf)[:-3])
        if shf.is_file():
            yield str(shf.name)


try:
    SCRIPTS = sorted(parse_pybin_scripts(PYTHONDIR / "Makefile"))
except (FileNotFoundError, ValueError, TypeError):
    # failed to find/parse the makefile, use the brute force method
    SCRIPTS = sorted(find_scripts(PYTHONDIR))

try:
    EXCLUDE = read_excludes(SRCDIR / "exclude-scripts.txt")
except FileNotFoundError:  # no exclusion file
    EXCLUDE = set()


# only parametrize if we have something to loop over,
# this allows pytest to exit with the 'no tests collected' code
# which we can then pass up the stack to automake
if SCRIPTS:
    @pytest.mark.parametrize('script', SCRIPTS)
    def test_help(script):
        if script in EXCLUDE:  # skip
            pytest.skip("excluded {}".format(str(script)))
        if CONDA_BUILD_TEST:  # script should be on the path
            check_call([script, "--help"], shell=False)
        else:  # use local path
            startdir = os.getcwd()
            os.chdir(str(PYTHONDIR))
            try:
                check_call("./{} --help".format(script), shell=True)
            finally:
                os.chdir(startdir)


# run from command line
if __name__ == "__main__":
    args = sys.argv[1:] or [
        "-v",
        "-rs",
        "--junit-xml=junit-scripts.xml",
    ]
    # run pytest with patch to not resolve symlinks
    with mock.patch("py._path.local.LocalPath.realpath", _ignore_symlinks):
        code = pytest.main(args=[__file__] + args)
    # handle exit code
    if code == 5:  # (pytest.ExitCode.NO_TESTS_COLLECTED)
        sys.exit(77)  # for automake check
    sys.exit(code)
